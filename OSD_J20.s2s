'$OSD4|On/off-line Sleep Detector  script
'======================================================================================= 
'	          CAMBRIDGE ELECTRONIC DESIGN LIMITED, THE SCIENCE PARK, MILTON RD., CAMBRIDGE CB6 0FE, UK
'========================================================================================

'Copyright Â© Cambridge Electronic Design.                    
'Author:	GH. 
'last modified: July 2016 GH.

'SOFTWARE REQUIRED:
'Spike 2 version 8.08 or higher
'The script makes use of script functions contained in the file GHutils.s2s
'You will find this additional script in a folder called <include> inside the Spike(n) folder in <My Documents>.
'                                                                                                               
'Save this script, the default sampling configuration <OSD.s2cx> and output sequence <GH_OSD3.pls> together in the same folder
'inside the <Spike n>  directory in <My Documents> (where n stands for the version number -8 or higher).

'HEALTH WARNING:
'The script is a <work in progress> and is offered without guarantees.
'Report any problems to:            geoff@ced.co.uk

'KEYWORDS
'sleep stage, paradoxical sleep, online, offline,chick, rat, mouse, theta : delta ratio


proc USER_GUIDE()
'OVERVIEW
'This script is intended for on- and off- line detection of sleep stages, that is, WAKE, REM and NREM (non-REM) in chicks, mice or rats.
'Optionally, the script can generate trains of digital output pulses when a particular sleep state is detected.
'                                                                                                          
'Sleep staging is based on recordings of one channel of emg and one channel of EEG per animal, recorded via chronically
'implanted electrodes. Up to 4 animals can be recorded and staged simultaneously.
'                                                                                
'In the initial stage of analysis, the script plots EEG power in up to 4 discrete frequency bands: delta and theta
'plus two optional user-defined bands.
'Theta : delta ratio (T:D) is also displayed. Sleep stages are then assigned based on EMG level -smoothed root mean square, rms.
'and the power in spectral bands.
'You can set your own criteria for identifying sleep states in a dialog.
'For each sleep state you can set a threshold level of emg activity and a threshold level in one spectral band (or T:D ratio).
'An example set of criteria might be:
'                                    
'Assign to REM if smoothed rms emg <= thr1 AND theta : delta ratio >= thr 2
'                                                                          
'Time ranges where the criteria are fulfilled (or not) are displayed as level channels, that is a level of 1 where the criteria
'are met otherwise zero. These level channels are then combined to generate a sleep state channel where epochs are assigned to
'a colour-coded sleep state based on a majority (of time) verdict.
'The default epoch duration is 20s. However, you can set a different value by editing the variable <sdur> below.
'When part of an epoch does not meet the criteria for any of the defined sleep states it can be marked as "Doubtful".
'Similarly, if parts of an epoch are marked as belonging to more than one sleep state, they can be marked as "Ambiguous".
'You can specify the precise criteria for epochs to be defined as Doubt (D) or ambiguous (?) in the DEFINE sleep stage dialog(s).
'                                                                                                                          
'The script can also generate a patterned output of pulses from the digital outputs of the 1401 interface when a particular
'sleep stage is detected. These pulses can be used to control external devices, e.g to turn room lights on or off for example.
'A more sophisticated application would be in optogenetic studies. The pulses can be used to trigger a laser to activate or inactivate
'specific genes.

'SAMPLING CONFIGURATION  (e.g., OSD.s2cx)
'Requirements: 1 channel of EEG, one channel of EMG and (optionally) one stimulus monitor channel per animal.
'                                                                                                            
'EEG channel titles MUST contain the string:  "EEG", Similarly emg channel titles must contain the string "EMG".
'Channel titles must also be non-identical. We recommend that you append the animal number, that is "EEG 1", "EMG 1", EEG 2, EMG 2 etc.
'Sample rate for EEG channels should be the same for all and greater than 512 Hz.
'The example config. assumes an EEG preamplifier gain of x10 000 and scales the Y-axis in micro-Volts.
'You will need to adjust the channel units, scale and offset of the EEG channels if you use 
'a different preamplifier gain.
'                              
'EMG channels should have a higher sample rate. A rate of 5kHz is used in the example configuration.
'The example config. assumes a preamp. gain of x1000 and a Y-axis scale of mV. Edit the scale and units for different preamp gain.
'                                                                                                                                
'You need stimulus monitor channels if you want to generate (and monitor) digital outputs in response to particular sleep states.
'These monitor channels must be LEVEL channels with a maximum event rate high enough to acommodate the stimulus pulse repetition rate
'that you require. These channels use the Event inputs of the 1401. Two channels are available on the front panel of Power and Micro1401 interfaces.
'If you require more, you will need to connect via the digital inputs connector on the rear panel of the 1401 either via a special break-out
'box (CED 2805DIO-8) or a home-made custom cables.
'Note: Check the box on the Sampling tab of the PREFERENCES dialog to switch Event outputs 0 and 1 to the rear panel.
'You will need to split each digital output signal, e.g using BNC T-pieces, between the output device and the appropriate stimulus monitor input.
'                                                                                                                                      
'Two digital outputs are available via BNCs on the 1401 front panel. If you need more then you must access them via the digital outputs
'connector on the rear panel of the 1401 interface using the CED 2805DIO-8 break out box,for example.
'See the online help for connection details if you decide to make up your own custom cables and connectors.
'                                                                                                                                    
'The example configuration is set up for two animals. You can expand it to 3 or 4 animals by duplicating channels, editing channel
'titles etc. in the Channels tab. We also recommend that you click on the SET button on the Channels tab and increase the number of
'available channels in the file to 100vsle. This means that further analysis of the data offline will not be restricted by lack of spare channels.

'Note that script identifies channels by their titles so it does not matter which channels or 1401 input ports that are used for each animal.
'                                                                                                                          
'After editing the sampling configuration, ALWAYS go to the RESOLUTION tab and select the model of 1401 that you are using.
'Click the 'SUGGEST' button to configure sampling so that you achieve sample rates as close as possible to the ones you requested.
'Now SAVE the edited configuration under the same name via Save Configuration As... on the Spike2 File menu.
'                                                                              
'The scipt prompts you to browse to a suitable sample configuration before recording or use the same configuration as the on the
'previous occasion that the script was run. So, you can create several configurations e.g. for different numbers of animals and
'choose the appropriate one when the time comes.

'PULSE OUTPUT
'The script can generate a train of digital pulses when a target sleep state is detected in any given animal.
'If 4 animals are recorded then digital outputs 0 to 3 are used. The system does not have 4 completely independent 'stimulators'.
'Rather there is a single stimulator generating a single pulse pattern that plays out once for every epoch of sleep staging.
'The script simply decides whether or not to switch output pulses on or off for a given animal and epoch based on the current sleep stage
'and various other criteria. Trains of brief pulses are required for optogenetic studies. The stimulus options provided should be suitable
'this application:
'                 
'The aspects of stimulation that are common to all digital outputs are set up via the PREFERENCES button on the script toolbar.
'This, among other things, opens an OUTPUTS dialog.
'Here, you can define a pulse train which MUST fit within a sleep staging epoch specifying:
'                                         
'   the duration of individual pulses (ms)
'   inter-pulse interval (ms)
'   Number of pulses in a train.
'   Number of consecutive epochs to repeat the stimulus whether or not the target sleep state continues (trains per sequence).
'   You can also specify an upper limit to the number of such sequences of stimuli that are presented,
'   i.e., the system will stop responding to the target sleep state.

'You can achieve an almost uninterrupted train of pulses extending over multiple epochs by careful choice of parameters.
'You can also specify a refractory period, a minimum delay after presentation of a sequence of outputs before
'the system responds again to a target sleep state. The Refractory period is set in the STAGE DEFINE dialog.
'Thus, you can set different refractory periods for different animals if you wish.

'There is also a scheduling scheme that allows you to specify the time when recording will start and stimulation will start and end.
'Such scheduling is set up separately at the start of each recording session.

'USER GUIDE
'When you run the script for the first time, it will install a hotkey labeled <OSD4>  on the Script bar. This button
'gives you one-click access to the script in future.
'The script toolbar has 21 buttons That enable and disable to help you to press them in a logical sequence.

'BUTTONS:
'RESET | PREFERENCES | GATED POWER | TABLE | EDIT SLEEP STATES | MARK TRANSITIONS | DEL PROC | DEL SEL |ABORT
'START | SHOW | DEFINE 4 / 3 / 2 / 1 | BANDED POWER | CHANNELS | RERUN | OFFLINE | ONLINE | QUIT

'INITIAL SET UP

'PREFERENCES
'Run the script and click the PREFERENCES button.
'The first dialog sets preferences for recording a new sleep data file. 
'You can opt to show a power spectrum that updates at the end of each sleep staging epoch.
'You can also set how often the Y-axes of incoming data channels are optimised and whether to include the EEG and EMG
'channels in the optimisation.

'OUTPUTS dialog
'Here you can set up the pattern of digital output pulses to generate when a target sleep state is detected. You will get a
'warning message if you try to create a pulse train longer than a sleep staging epoch.
'Trains per sequence is the number of consecutive epochs on which to repeat the output after triggering.
'Set number of sequences to zero for 'no limit' to the number of sequence presentations.
'When you click on OK, these settings will be stored and used until such time as you change them.
'Further Scheduling options for stimulation are availeble at the start of every recording session.



'USING THE SCRIPT

'The correct sequence of button presses depends on whether you want to:
'a)       analyse a pre-existing data file
'b)       re-run an existing data file to simulate online sleep staging
'c)       identify sleep episodes online

'Before attempting online analysis, try analysing a few data files offline to familiarise yourself and
'to establish the best parameters to use for your particular study.
'You can then simulate an online experiment by re-running an existing but un-analysed data file.
'You will then be in a position to try assigning sleep states online.

'==========================================================
'a)  ANALYSE A PRE-EXISTING DATA FILE.
'Run the script and then click OFFLINE. The script will adopt the currently displayed time view if there is one
'or open a dialog for you to browse to the file to analyse. Make sure that the EEG and EMG channels are 
'visible and that the channel titles contain the strings "EEG" and "EMG" respectively, so that the script can identify them.
'A data file containing mouse sleep (Mousesleep3.smrx) data is supplied with this script. You can use this file to practice on.
'It contains EEG and EMG sleep data for 3 mice (-actually data from 1 mouse copied 3 times with slight time offsets).
'                                                                                                           
'Next, click on CHANNELS. In the dialog, you can opt to process data from up to 4 animals by checking boxes.
'For each animal, select the appopriate EEG and EMG channel. and click on OK. The OK button will be disabled if the script
'detects that the channel assignments are incorrect.
'                                                   
'Next, click on BANDED POWER.
'Normally a dialog will open for you to pre-process the emg and eeg channels and specify the spectral band channels to create.
'However, if spectral band channels already exist within in the file, there will be an option to use the existing channels 
'rather than creating new ones.

'When using the dialog:
'1)  Set the time constant for root mean square processing of EMG -(akin to rectify and smooth).  The default is 5s (=+/-5s).
'If you use the spinner arrows in the dialog, you can observe the effect of changes on the EMG waveforms directly. 
'                                                                                
'2)  a smoothing time constant for spectral power in band channels ( default 5s).
'                                                                                
'Four spectral power bands are allowed. Delta and Theta bands are available as standard. You must set the 
'frequency limits of these bands (defaults: 0 to 4 and 6 to 10 Hz respectively).
'Two other bands can be enabled if required by checking boxes, entering a title for the band and setting the frequency range.
'All settings in this dialog will be applied to data from all animals in the study.
'Click on OK to continue.
'                        
'At this point, EEG channels will have been interpolated to a sample rate of 512 Hz and the EMG channels converted
'to rms and smoothed with the chosen time constant. (These changes are channel processes and thus completely reversible
'See the Spike 2 Help under channel processes for further info).
'                                                               
'Power in each band together with T:D ratio are then calculated using the spectral functions of Virtual channels 
'and the (smoothed) results are saved to disk-based channels. This process may take a significant amount of time.
'Progress is indicated on the toolbar.
'                                     
'If you are only interested in plotting banded power you can QUIT the script at this point.

'SETTING SLEEP STAGE CRITERIA:
'If you wish to identify sleep stages based on banded power and emg activity, click on a <DEFINE n> button.
'There are four DEFINE-n buttons to set the sleep staging criteria for animals 1, 2, 3, and 4 respectively. Buttons are only enabled
'if data exists for the corresponding animal.
'When you click a DEFINE-n button data channels from other animals will be hidden in order to show data from the
'current animal with maximum detail.

'You can specify the sleep stage criteria in the dialog.
'In the first instance, we suggest that you set the criteria for one sleep stage at a time. For example, to set the WAKE parameters.
'Check the appropriate checkbox, and uncheck the boxes for NREM and REM. Show the entire time range of the example file
'so that episodes of wakefulness quiet sleep and paradoxical sleep are displayed.
'                                                                                
'The usual criteria for WAKE are high emg activity combined with high T:D ratio (or possibly low delta power)
'For the example data file we suggest that you set the criteria:
'EMG >= 7.1    +     T:D   >=  5
'Note that a Virtual channel will appear in the data file showing the periods where the criteria are met.
'The channel title will be WAKE (n) where n is the channel number of the source EEG channel (not the animal number).
'Horizontal cursors are shown in the EMG and T:D channels showing the current thresholds. You can change the thresholds
'via the spinner controls in the dialog or by dragging the horizontal cursors with the mouse. The Virtual WAKE channel will
'update accordingly.  You can adjust the levels in order to take account of variation between individuals.
'The <Suggest> button will offer settings based on the mean and standard deviation of emg T:D ratio and power in delta.
'The <Suggest> button is only available for offline analysis.
'If the horizontal cursors are not visible in the channel, you can click the FETCH H_CSRS button to reset them to mid-screen.
'You may need to use click on Y-axis of a channel and press Ctrl and drag to adjust the Y-range of a channel in order to zoom in on
'the area of interest.
'If you want to use only one criterion, you can switch off the other one by selecting <nop> <no operation> instead of <= or >=.
'                                                            
'Now, uncheck the WAKE checkbox and enable the NREM settings.
'The recommended criteria here are low EMG combined with high delta power.
'Try: EMG <= 7.1   + Delta >=  955
'As before, a Virtual channel will mark the regions that meet the criteria and you can  adjust the thresholds by clicking on
'the spinner controls in the dialog or dragging the horizontal cursors.
'                                                        
'Finally, repeat the process, for the REM sleep settings.
'This sleep stage is characterised by low EMG combined with high T:D ratio.
'The following criteria work for the example data file.:
'EMG  <=  7.1   +   T:D>=6.3
'                           
'When you are satisfied with the criteria for individual sleep stages, check all three boxes and inspect the 3 Virtual sleep stage channels.
'If you have chosen the criteria wisely then a very large proportion of the data will fall into one (and only one) of the three categories.
'However, inevitably there will be some periods which do not meet any of the criteria and others which are ambiguous, being assigned 
'to more than one state. Areas of ambiguity are marked in a Virtual channel labelled "ambiguous" Periods of doubt and ambiguity can be highlighted
'in the final sleep state channel using the criteria that you set in the DOUBT section of the dialog.
'Note that it is not necessary to enable the search for all three sleep states. Just enable the ones that you are interested in.
'
'If you require digital output pulses, then check the box in the Pulse outputs section. Choose the sleep state that triggers outputs and
'set the refractory period between output sequences.
'                                                                                
'UN-check the ENABLE pulse outputs box initially and then click OK in the dialog.
'The dialog will close and the file will be divided into epochs (default value 20s) and each epoch is assigned to which of the three sleep
'states occupied the majority of the time. However, the DOUBT section of the dialog allows you to override the majority vote if the
'proportion of the epoch that is unclassified or ambiguous exceeds a threshold level.
'                                                                             
'You can press a DEFINE-n button again to modify the sleep stage definitions. 
'Press it and this time Check the box to ENABLE Pulse outputs. Select a sleep stage to trigger them and set a refractory period,
'that is, a minimum time between sets of output pulses.
'When you click on OK, an additional level channel is created (labelled: Pred.(n)) that shows the predicted pattern of output pulses that
'would have been generated if these criteria had been used on-line.
'
'You can set different criteria for sleep stage detection for each animal via the numbered DEFINE buttons. This may be useful to take account of 
'differences between individuals and different recording quality.

'Clicking on CANCEL in this dialog will delete the Stage Marker, predicted Pulse output channel and the individual state marker channels for WAKE, NREM etc.
'Clicking on OK will update the sleep stage marker and predicted pulse output based on any changes you have made.
'Either way, the dialog will close leaving data from only one animal visible. Click on the SHOW button to display data from a different animal or all animals.
'=============================================================

'Additional Toolbar buttons:
'RESET
'Click here to delete all channels created by the script, that is: power spectral channels, sleep stages, predicted outputs.
'Sampled data will be unnaffected. There is an "Are you sure?" query in case you change your mind.
'This feature is useful if you want to re-analyse data multiple times to try out different settings.

'DEL SEL
'Similar to reset:
'New channels generated by the script are shown "selected ", that is, with highlighted channel numbers. 
'This button allows you to delete all currently selected channels with no questions asked. You can select or un-select individual channels
'by holding down CTRL and clicking on channel numbers with the mouse.

'DEL PROC 
'Clicking on this button clears all channel processes in the data file. For example it will undo the interpolation of the EEG channel 
'and the smoothed root mean square processes on the emg returning it to its 'raw state.

'MARK TRANSITIONS
'This function adds vertical markers at each transition between different identified states but not transitions to or from ambiguous or
'doubtful epochs.  Adding these marks makes it easier to relate the state changes with changes in the underlying power and emg channel.
'You can hide the Vertical markers by pressing the toolbar button a second time.

'EDIT SLEEP STAGES
'This button provides a series of tools for editing the newly created sleep stage channel. You can use these tools to edit epochs
'that are currently listed as DOUBT (D) or AMBIGUOUS (?) for example. Alternatively, you can re-assign states that you judge to be incorrect.
'                             
'EDITING TOOLBAR:
'SINGLE EPOCH MODE|MULTI-EPOCH MODE|PREVIOUS|<W>|NEXT|WAKE|NREM|REM|DOUBT|AMBIG|BACK|
'                                            
'SINGLE/MULTI EPOCH MODES
'Select single epoch mode to assign a sleep state to the epoch containing Cursor 1. 
'Press Ctrl+1 to fetch the cursor. Drag it into the stage to edit and then click on the relevant toolbar button (WAKE, NREM, REM,DOUBT or AMBIG)
'or the associated hotkey (underlined in the button label) to edit the stage.
'Select Multi-epoch mode to assign all epochs bracketed by two cursor to the chosen state. YOU can fetch the cursors with Ctrl+1 and Ctrl+2.
'                  
'Navigation:
'In single epoch mode, you can jump to the Next or Previous epoch of a selected type via the NEXT and PREVIOUS buttons.
'Click repeatedly on the area between the next and previous buttons in order to select the sleep stage to search for (W/N/R/D/?/Any)
'You can use the cursor arrow keys as shortcuts.
'Click on BACK to return to the main toolbar.

'TABLE
'Click here to display a summary table of the distribution of sleep stages in the file. The file is divided into 
'sections of user-defined duration and the number of epochs of each type and the proportion of the time occupied 
'by each state is shown section by section. You can copy the table to a spreadsheet via the clipboard or saved
'the file via File Save as... on the Spike2 File menu. Click on the Close or Minimise  boxes to hide the table.

'GATED POWER
'Click here generate power spectra for all epochs of specified type , e.g. Wake, in a time range.
'A dialog allows you to select the relevant channels , time range and sleep stage.
'=================================

'RE-RUNNING DATA FILES
'You can simulate online sleep detection by re-running an existing un-analysed data file.
'Click on RESET first if the file has already been analysed.

'Open the data file on the desktop and click on RERUN.
'Select the start time and rerun speed etc. in the dialog and press OK.
'Click on BANDED POWER to set up the power in band channels as you would for offline analysis.
'New power in band channels are created when you click on OK. These channels are initially empty.
'                                                                           
'Next, click DEFINE button(s) for each animal and set up the required criteria and click on OK.
'New channels are created ready to hold the on/off data for individual sleep states together with the
'sleep stage marker channel and a predicted pulse output channel.
'Click on SHOW and select which animal to display or select ALL ANIMALS.

'Make sure that the 1401 interface is switched on and then press START to begin the re-run.
'Sleep states will be assigned shortly after the end of each epoch.
'If selected, output  pulses (or simulated o/p pulses, in this case)  will be generated as soon as an epoch of the required
'type is detected. Since epochs cannot be assigned to a sleep state until they finish, an output pulse can only be generated
'at the start of the following epoch and thus will lag by 1 epoch duration.
'Note that, you can open a <DEFINE-n> dialog at any time and adjust the Stage definitions. Sleep staging will continue to work 
'while the dialog is open and any adjustment that you make will take effect immediately but not retrospectively on the sleep stage
'marker channel. (Note the on/off states of individual state marker channels for WAKE NREM etc. DO change retrospectively and therefore
'will not match the Stage marker after you have adjusted the definitions).

'Note that You can only view data from the current animal while a DEFINE dialog is open. After closing the define dialog,
'results from all animals are displayed. you can click on SHOW to display a single animal if required.
'Since changes that you make in this dialog take effect immediately, there is no <CANCEL> option online or when re-running.

'STOP  Click here to stop the RE-RUN.

'=====================
'ONLINE SLEEP DETECTION

'This should work in much the same way as re-running an existing data file.
'To start online sleep detection:
'Switch the 1401 interface on and run the script via its script bar hotkey (OSD4)
'Control the recording using the toolbar buttons:

'PREFERENCES            Click here to set up the frequency at which traces are optimised during recording and whether to show power spectra
'                       as histograms. You also need to set up the required pattern of pulses to output when a target sleep stage is detected
'                       before you start recording. Your settings will be stored and used in future recordings until such time as you change them.

'ON-LINE                First select the sampling configuration to use for recording. You can select the one that you used last time or
'                       browse to a different one. You can opt to show a power spectrum that updates at the end of each sleep staging epoch.
'                       Next choose MANUAL  or SCHEDULED recording. If you choose MANUAL then recording will be controlled by the START and STOP
'                       buttons on the main toolbar. If you select SCHEDULED then a dialog opens ehere you can set up:

'                      *   The date on which recording should start
'                      *   Time of day when recording should start in 24hr clock format
'                      *   Duration of the recording
'                      *   Time delay between start of recording and enabling of outputs
'                      *   duration of the time window when outputs are enabled.

'                      NOTES:  ONLY the Start time of recording is a CLOCK TIME. the other items are time delays and time intervals (max:24hr)
'                      If you want recording to stop at a given clock time or stimulation to be en/dis-abled at a particular clock time.
'                      then you must do the maths to covert these times to time delay after start of recording etc.
'                      Scheduled start time must be at least 5 minutes in the future and recording duration must be at least 5 minutes.
'                      The time to enable outputs must be within the scheduled recording period (obvs).
'                      If you set the duration of the OUTPUTS window to zero then outputs will be enabled until the end of recording.
'                      The Scheduled dialog always opens showing today's date. The other items in the dialog remain the same between trials.
'                      The new data file opens when you close the Schedule dialog.


'CHANNELS              assign the EEG and EMG channels in pairs from each animal.
'BANDED POWER          set up the power in band channels
'DEFINE-n              set up the initial sleep stage detection criteria for each animal. These can be adjusted during recording by
'                      pressing the DEFINE-n button again. Your changes will be applied to the State marker channel immediately.
'                      Effects on individual State markers (WAKE, NREM etc. are retrospective and therefore no longer valid.

'In SCHEDULED mode the system will start automatically at the appointed time. In MANUAL mode you must press the START button.
'Beawre: pressing START in SCHEDULED mode will override the timetable that you set up. The time window during which outputs are enabled
'will be bracketed by vertical Markers in scheduled mode.

'START                 starts sampling
'                      if the criteria for pulse generation are met then trains of digital output pulses will be generated from
'                      digout channels 0 to 3 where channel 0 (bit 8) maps to animal 1, channel 1 (bit 9) maps to animal 2 and so on...

'ABORT                 stops sampling and discards the file
'STOP                  stops sampling and saves data to permanent channels .Use the Spike2 File menu to save the file to disk.
'QUIT                  stops any sampling and closes the script
end;

proc REVISIONS()                                        ' revision history only (no code within)
'08/03/2016
'nseqmx%     Setting 0  as maximum nr of outputs in the OUTPUTS dialog now sets number of repetitions to v. large number (10 million).
'trfr[]      this array of times when the last refractory period ends is now reset to zero when sampling starts.
'            Previously, if you sampled, some outputs were generated and you pressed <Abort> then
'            no stimuli were generated next time around until the recording exceeded the duration of the previous (aborted) session.
'            There is now a warning message if you try to start sampling without setting up the <Stage definitions> on ALL animals.
'            Previously, the script would crash when you clicked the START button.
'            On-line, the script now reports which output channels are active on the script toolbar.
'            Minimum refractory time in <Stage Define> dialogs now reduced to zero .Previously there was a minimum gap of 1 epoch between stimulus trains.
'15/07/2016  Added toolbar buttons to shift time range of current time view left and right in units of the current width.
'            Added 2 checkboxes to preferences to enable/ disable optimisation and to display or hide data from other anaimals during STAGE DEFINE process.
'            Epoch (sleep stage) duration now saved in the profile and can be modified in the Preferences dialog.
'            The block duration set in the <Table Set Up> dialog becomes the default setting in future trials.

'            Edit Sleep States now includes the option to skip from one stimulus train to the next as well as from one sleep epoch of selected type to the next.
'            You can now press Cursor Up-Arrow repeatedly to cycle through the options of which sleep state (or Stimuli) to skip to.
'            When navigating around stimulus trains, the skip step is determined by the train duration set up in the PREFERENCES.
'            A bug in the Table function has been fixed.
'            There is now more error checking to trap attempts to create a table of results using an invalid time range or block size.
'            Under some -as yet unidentified circumstances, online sleep-staging can add spurious epoch markers. The sleep stage code (and the colour) is the
'            same as the previous, correctly timed marker, making these extra markers difficult to spot by eye. A new button on the main toolbar,
'            "CHECK SLEEP-STATES" allows you to search for and hide these unwanted markers. It searches for markers at unexpected time intervals and gives you the
'            option to change the marker code to one which the script always keep hidden (code 255). There is also an option to reinstate markers that were hidden in this way.
'            It is wise to check for spurious markers before tabulating results in order to avoid arrors.
'29/11/2016  Clicking on <Suggest> in the Stage Define dialog could cause the script to hang if there were gaps or regions of NaN at the start and end of a T:D ratio plot.
'            This problem is fixed by applying Skip NaN and Fill Gaps channel processes before attempting to take measurements. (Requires Spike2 v 8.11 or higher).
'            Adopted changes suggested by AV. For example, Forward and backward by 1 screen also in the Editing toolbar (Hotkeys: comma and period).
'            Dialogs now remember their positions if dragged by the user.
'            Flashing cursors when a spurious SS marker detected is now replaced by a warning BEEP.
'            Gated Power button now disabled while sampling or re-running.
'15/12/2016  DEL SEL buttons now puts up an "Are you sure query?" if the list of selected channels includes waveforms
'            (that is: discourage user from throwing away the sampled raw data).

end;

'=================================
var sdur$:="5.0",sdur;                                         ' set epoch duration here (recommended setting is 20s)
var stim_dur:= 10.0;                                    ' set stimulation duration for skipping to each stimulation
var trdur,trdur$;
'=================================
const on%:=1, off%:=0,all%:=-1;
const quitbtn%:=1, newbtn%:=2, oldbtn%:=3, rrbtn%:=4, chansbtn%:=5, setupbtn%:=6;
const sd1btn%:=8, sd2btn%:=9, sd3btn%:=10, sd4btn%:=11, showbtn%:=12; 
const samplebtn%:=14,sabortbtn%:=15,delselbtn%:=17,delprocbtn%:=18,vmbtn%:=20,chkbtn%:=21,editbtn%:=22,tablebtn%:=23,gpwrbtn%:=24,prefsbtn%:=25;
const resetbtn%:=26, rbtn%:=28,lbtn%:=29;
'-----OSD4 variables--------
var gnow%[6];
var sperm%[12]:={31,28,31,30,31,30,31,31,30,31,30,31};  ' days in each month (cope with leap years later)
ArrMul(sperm%[],3600*24);                               ' convert to seconds per month

var vmch%;                                              ' vertical mark channel
var ftd%[6];                                            ' time when sampling started 
var leeway;                                             ' time (s) until Channel processes have settled on-line

var pwrlst%[6];                                         ' list of power in band channel (Stage Define%()
var pchndx%[3][4];                                      ' power channel slector in Stage define dialog
var stt,endt;                                           ' times of pulse pattern
var pulsesch%;                                          ' channel for pulse pattern used during re-reun
var dlgopenflg%;                                        ' 1: stage define dialog is open, otherwise 0.
var showflg%;                                           ' flag show dialog open or not.
var showopt%;                                           ' 0: show all data; 1-4 show data from a single numbered animal
var shw%;                                               ' currently displayed animal
var pulseon%[4],ntrains%[4],vdigout%,lastpo;
var trfr[4], pulse_end[4];                                            ' expiry time of refractoriness after previous stimulation for 4 channels
var pls$,tpls,ipi,np%,ntr%,nseqmx%;                     ' pulse duration,inter-pulse interval, n pulse, ntrains, inter-train interval
var nseq%[4];                                           ' number of stimulus trains applied to each animal
var lasthcch%[6];                                       ' home channel for each horizontal cursor (stop user from dragging to a different one!)
var nfound%;                                            ' number of possible pairs of EEG/EMG chans found in current file (ChanSetup)
var ii%;                                                ' previous state of stage define checkboxes
var rawchk%;
var emgch%[4],eegch%[4],onchk%[4],nchk%,anr%;
var deltach%[4],thetach%[4],tdch%[4],udbndch%[2][4];
var key$:="OSD4",emgeeg$;
var blockdur,blockdur$;                                 ' block size used in Report (saved in Profile)

var stdate$,sttime$,stdate0$,sttime0$,stdate1$,sttime1$,stdate2$,sttime2$; ' date and time of scheduled stimulation and scheduled recording start/end as strings
var sss%,twdone%,stimflag%;                             ' sec since start, time window threshold reached, flag enable output pulses 
'---------------------------
var toptim;                                             ' auto-optimise interval
var optimchk%;                                          ' checkbox to apply auto-optimisation to eeg and emg channels
var sdoptchk%,sdhidechk%;                               ' extra preferences added 15/07/2016
var ok%;
var tvh%,pvh%[4],pscheck%:=1;
'================================
var relpath$;
var cfg$;
var seq$:="\AV_OSDcont.pls";
var set$,script$;                                
'================================
var rrchk%,rspeed,rrdac%:=-1,rrflg%,replay$;            ' re-run parameters  default is sound card
var ssndx%[4],trefract[4],ss%[4];                       ' pulse output
var bw;                                                 ' bin width 
var vthetach%[4],vdeltach%[4],vtdch%[4],dupssch%[4];   
var rmstc,tedgelo,tedgehi,dedgelo,dedgehi,bnds$;
var twin,fftsz%:=256,stepsz;                            ' related to power spectrum underlying power in band Virtual channels
var onofflineflg%;
var st;                                                 ' start time when re-running
var emgthr;                                             ' stored threshold and y-ranges
var hc%[7];                                             ' h cursors.; element [0] unused hc%[1] = hcursor1 etc...
ArrConst(hc%[],9);                                      ' cannot use 0 because HCursorExists(0) generates a run time error.
var opch%[4],opchk%[4],find_opch%;
var udbndchk%[2],udbndttl$[2],udedgelo[2],udedgehi[2];  ' user-defined power in band channels
var vudbndch%[2][4];
var udr[2]:={45,125};
var udg[2]:={179,208};
var udb[2]:={189,51};                                   ' user -defined band channels (Virtual and disk versions) +trace colours
var sschk%[3][4],ssdefch1%[3][4],ssopndx1%[3][4],sslvl1[3][4],ssdefch2%[3][4],ssopndx2%[3][4],sslvl2[3][4]; ' sleep stage define parameters for 4 animals
var ssch%[4][4],ssexpr$[4][4];
var op$[3]:={">=","<=","nop"};
var sslbl$[4]:={"WAKE","NREM","REM.","ambiguous"};
var r[4]:={55.0,114.0,22.0,192};   ArrDiv(r[],256.0);   ' convert from 0-255 to 0-1.
var g[4]:={73.0,234.0,245.0,64};  ArrDiv(g[],256.0);
var b[4]:={234.0,55.0,240.0,255};  ArrDiv(b[],256.0);   ' rgb colour settings  for sleep stage channels

var pcscored,pcambig,thr,thr2;                          ' related to percentage of an epoch scored as W, N or R.
var ssparams1$,ssparams2$,ssparams3$,ssparams4$,pulseparams$; ' sleep stage definitions in the profile
var ssparams1b$,ssparams2b$,ssparams3b$,ssparams4b$;    
var ssparams1c$,ssparams2c$,ssparams3c$,ssparams4c$;    
var ssparams1d$,ssparams2d$,ssparams3d$,ssparams4d$;    

var misc$;
var sstatech%[4];                                       ' sleep state channel
var lasttm;                                             ' time of sleep stage onset online (4 animals)  
var ss$[6]:={"","W","N","R","?","D"};
var tc:=1.0;                                            ' smoothing time constant for disk-based power in band channels
var stagedefineflg%;
var di%[20];                                            ' dialog item nr

var fftlst$[11]:={"16","32","64","128","256","512","1024","2048","4096","8192","16384"}; 
var fftndx%,wdwndx%;                                    ' gated power spectrum dialog parameters
var txt%[2];

'======start and end sampling related=======================
var begin%[6], begin$;                                  ' , finish[6], curr_time%[7], tdate%[6], seq[6]; ' variables for samp_start%() and samp_end%();
var rdursec%,stimonsec%,stimoffsec%;
var ttableflg%;                                         ' flag manual (0) or scheduled recording
var stdr%[3];                                           ' duration of stimulation period in hh:mm:ss

var sndx%,eegchan%,stg,etg;
'=====stage-editing related ======
var editch%,stagesel%,lbl$,multiflg%;
var mc%,vmflag%;                                        ' marker code for currently selected stage to find with <Next/Previous>
const swmulti%:=12,swone%:=13;
'============================
var dt%[8],dg%[8];                                      ' dialog text and group item nrs for ChanSetup%(
var dxra$,dyra$;                                        ' arrays of dialog coordinates embedded in strings for storage in the profile
var ndlgs%:=20;                                         ' Number of dialogs with remembered screen coordinates
var dxra[ndlgs%],dyra[ndlgs%],drandx%;                  ' arrays of dialog coordinates and the index of which set to use for a particular dialog

'======for log file naming and saving purposes=======================
var samp_name$ := SampleAutoName$();            'ANNE: for saving/naming log file
var samp_dir$ := FilePath$(3);

'MAIN
#include "ghutils.s2s"                                  ' include library of script functions
docase
case App(-1)>=800 and App(-1) < 807 then
    Message("This script requires Spike2 v8.03 or higher. You are running v%.2f.\n"+
    "Download the free upgrade from the CED website and retry.",App(-1)/100.0);
    halt;
case App(-1)<700 then
    Message("This script requires Spike2 v 8.07 or higher. You are currently running v%.2f.",App(-1/100.0));
    halt;
endcase;

Profile(key$,"ep","5.0",sdur$);                        ' get stored value of epoch duration. (Can be changed in <Preferences>)
sdur:=Val(sdur$);

Profile(key$,"Config","",cfg$);
script$:=View(App(3)).FileName$(0);                     ' full name including volume and path
relpath$:=View(App(3)).FileName$(1)+View(App(3)).FileName$(2); ' set the path to ancillary files (config/sequencer) to same folder as running script
set$:="OSD4|"+script$+"|Online Sleep Detection (up to 4 animals)"; ' label for script bar button
'====================
'AddScriptBarBtn%(set$);                                 ' comment this line if you do not want to add a button to the Script bar
'====================
ColourSet(1,10);                                        ' marker colour table size
ColourSet(1,9,1,1,1);                                   ' white marker for terminator 

View(App(3)).WindowVisible(2);                          ' iconise the script

Profile(key$,"Pulses","5,95,30,12,0,0,0",pls$);         ' get previous (or default) pulse settings
ReadStr(pls$,tpls,ipi,np%,ntr%,nseqmx%,sdoptchk%,sdhidechk%);
Profile(key$,"Begin","",begin$);
ReadStr(begin$,begin%[2],begin%[1],begin%[0],rdursec%,stimonsec%,stimoffsec%); ' get scheduled onset time  and scheduled duration hh:mm:ss, sec.
Profile(key$,"table","300.0",blockdur$);
blockdur:=Val(blockdur$);
Profile(key$,"skipdur","10.0",trdur$);
trdur:=Val(trdur$);                                     ' get skip duration from registry

ProfileInfoGet();                                       ' get stored set up info
FindView(tvh%,0);
Profile(key$,"dxra","",dxra$);                          ' read list of dialog coords from registry
Profile(key$,"dyra","",dyra$);                          
ReadStr(dxra$,dxra[]);                                  'copy from strings to real arrays
ReadStr(dyra$,dyra[]);
if ViewKind(tvh%)=0 then FrontView(tvh%); endif;
DoToolbar();
SaveDlgCoords(key$,ndlgs%);
halt;

func Cancelx%()                                         ' special <Cancel> and <OK> button for storing dialog-s coordinates when it is closed
DlgGetPos(dxra[drandx%],dyra[drandx%]); 'position relative to application window
return 0;
end;

func OKx%()
DlgGetPos(dxra[drandx%],dyra[drandx%]);  'coords rel. to application window
return 0;
end;

proc SaveDlgCoords(key$,ndlgs%)                         ' save dialog coordinates to registry
var i%;

dxra$:="";                                              ' delete old coordinates
dyra$:="";
for i%:=0 to ndlgs%-1 do
    dxra$+=Print$("%.1f,",dxra[i%]);
    dyra$+=Print$("%.1f,",dyra[i%]);
next;
Profile(key$,"dxra",dxra$);                             ' save current dialog coordinates to the registry
Profile(key$,"dyra",dyra$);
end;


func CfgBrowse%()
var ok%;

ok%:=FileOpen("",6,0,"Choose a Configuration");         ' browse to and load a sampling configuration from disk
if ok%<0 then halt; endif;                              ' user cancelled or some other problem
cfg$:=SampleConfig$(0);
Profile(key$,"Config",cfg$);                            ' save the path to this config for current and future use
return 0;                                               ' acts as OK button
end;

proc ProfileInfoGet()
var dummych%;
Profile(key$,"bandsetc","5.0,1,6.0,10.0,0,4.0,0,0,8.0,14.0,13.0,35.0,\"alpha\",\"beta\",5.0",bnds$);	
Profile(key$,"ssdef1","8,8,8,0,1,1",ssparams1$);        ' 1
Profile(key$,"ssdef1b","8,8,8,0,1,1",ssparams1b$);      ' 2
Profile(key$,"ssdef1c","8,8,8,0,1,1",ssparams1c$);      ' 3
Profile(key$,"ssdef1d","8,8,8,0,1,1",ssparams1d$);      ' 4

Profile(key$,"ssdef2","10,10,7,0,0,0",ssparams2$);
Profile(key$,"ssdef2b","10,10,7,0,0,0",ssparams2b$);
Profile(key$,"ssdef2c","10,10,7,0,0,0",ssparams2c$);
Profile(key$,"ssdef2d","10,10,7,0,0,0",ssparams2d$);

Profile(key$,"ssdef3","0,1,0,9,8,9",ssparams3$);
Profile(key$,"ssdef3b","0,1,0,9,8,9",ssparams3b$);
Profile(key$,"ssdef3c","0,1,0,9,8,9",ssparams3c$);
Profile(key$,"ssdef3d","0,1,0,9,8,9",ssparams3d$);

Profile(key$,"ssdef4","0,0,0,0",ssparams4$);
Profile(key$,"ssdef4b","0,0,0,0",ssparams4b$);
Profile(key$,"ssdef4c","0,0,0,0",ssparams4c$);
Profile(key$,"ssdef4d","0,0,0,0",ssparams4d$);

Profile(key$,"pulse","2,2,2,2,30.0,30.0,30.0,30.0,50.0,10.0,\"D\",\"?\"",pulseparams$); ' common pulse parameters for all animals
Profile(key$,"misc","5.0,1,1,1",misc$);                 ' auto-optimisation settings
Profile(key$,"chansetc","",emgeeg$);

ReadStr(emgeeg$,onchk%[0],onchk%[1],onchk%[2],onchk%[3],eegch%[0],eegch%[1],eegch%[2],eegch%[3],emgch%[0],emgch%[1],emgch%[2],emgch%[3]); ' read eeg and emg channels
ReadStr(bnds$,rmstc,dummych%,tedgelo,tedgehi,dedgelo,dedgehi,udbndchk%[],udedgelo[],udedgehi[],udbndttl$[],tc); ' read stored power band info for 4 animals (a,b,c and d)
ReadStr(ssparams1$,ssdefch1%[0][0],ssdefch1%[1][0],ssdefch1%[2][0],ssopndx1%[0][0],ssopndx1%[1][0],ssopndx1%[2][0]);
ReadStr(ssparams1b$,ssdefch1%[0][1],ssdefch1%[1][1],ssdefch1%[2][1],ssopndx1%[0][1],ssopndx1%[1][1],ssopndx1%[2][1]);
ReadStr(ssparams1c$,ssdefch1%[0][2],ssdefch1%[1][2],ssdefch1%[2][2],ssopndx1%[0][2],ssopndx1%[1][2],ssopndx1%[2][2]);
ReadStr(ssparams1d$,ssdefch1%[0][3],ssdefch1%[1][3],ssdefch1%[2][3],ssopndx1%[0][3],ssopndx1%[1][3],ssopndx1%[2][3]);

ReadStr(ssparams2$,sslvl1[0][0],sslvl1[1][0],sslvl1[2][0],pchndx%[0][0],pchndx%[1][0],pchndx%[2][0]);
ReadStr(ssparams2b$,sslvl1[0][1],sslvl1[1][1],sslvl1[2][1],pchndx%[0][1],pchndx%[1][1],pchndx%[2][1]);
ReadStr(ssparams2c$,sslvl1[0][2],sslvl1[1][2],sslvl1[2][2],pchndx%[0][2],pchndx%[1][2],pchndx%[2][2]);
ReadStr(ssparams2d$,sslvl1[0][3],sslvl1[1][3],sslvl1[2][3],pchndx%[0][3],pchndx%[1][3],pchndx%[2][3]);

ReadStr(ssparams3$,ssopndx2%[0][0],ssopndx2%[1][0],ssopndx2%[2][0],sslvl2[0][0],sslvl2[1][0],sslvl2[2][0]);       
ReadStr(ssparams3b$,ssopndx2%[0][1],ssopndx2%[1][1],ssopndx2%[2][1],sslvl2[0][1],sslvl2[1][1],sslvl2[2][1]);
ReadStr(ssparams3c$,ssopndx2%[0][2],ssopndx2%[1][2],ssopndx2%[2][2],sslvl2[0][2],sslvl2[1][2],sslvl2[2][2]);
ReadStr(ssparams3d$,ssopndx2%[0][3],ssopndx2%[1][3],ssopndx2%[2][3],sslvl2[0][3],sslvl2[1][3],sslvl2[2][3]);

ReadStr(ssparams4$,sschk%[0][0],sschk%[1][0],sschk%[2][0],opchk%[0]);
ReadStr(ssparams4b$,sschk%[0][1],sschk%[1][1],sschk%[2][1],opchk%[1]);
ReadStr(ssparams4c$,sschk%[0][2],sschk%[1][2],sschk%[2][2],opchk%[2]);
ReadStr(ssparams4d$,sschk%[0][3],sschk%[1][3],sschk%[2][3],opchk%[3]);

ReadStr(pulseparams$,ssndx%[],trefract[],pcscored,pcambig,ss$[0],ss$[4]);
ReadStr(misc$,toptim,optimchk%,pscheck%,rawchk%);
nchk%:=ArrSum(onchk%[]);
end;

proc DoToolbar();
MainToolBtns();
var btn%[9]:={1,2,3,4,17,18,25,28,29};
ToolbarEnable(all%,off%);
ToolbarEnable(btn%[],on%);                              ' enable: Quit, New, Off-line, ReRun buttons
Toolbar("  OSD4 :  Online sleep detection",1023);
end;

proc MainToolBtns()
ToolbarClear();
ToolbarSet(0,"idl",Idle%);
ToolbarSet(quitbtn%,"&Quit||Hotkey: Q",Quit%);
ToolbarSet(newbtn%,"O&Nline||Hotkey: N;  Detect sleep online",NewFile%);
ToolbarSet(oldbtn%,"O&FFline||Hotkey: F;  Detect sleep offline",SelectFile%);
ToolbarSet(rrbtn%,"&Re-run||Hotkey: R;  Simulate online with sleep stage detection",Rerun%);
ToolbarSet(chansbtn%,"&Channels||Hotkey: C;  Set up channels",ChanSetUp%);
ToolbarSet(setupbtn%,"&Banded Power||Hotkey: B;  Set up Power in band channels needed for sleep state detection",BPSetUp%);
ToolbarSet(samplebtn%,"&Start||Hotkey: S;  Start sampling or Re-run.",DoSStart%);
ToolbarSet(sabortbtn%,"&Abort||Hotkey: A;  Abort sampling and discard data files",SAbort%);

ToolbarSet(sd1btn%,"Define &1||Adjust Stage criteria for # animal 1.   Hotkey: 1",StageDef1%);
ToolbarSet(sd2btn%,"Define &2||Adjust Stage criteria for # animal 2.   Hotkey: 2;",StageDef2%);
ToolbarSet(sd3btn%,"Define &3||Adjust Stage criteria for # animal 3.   Hotkey: 3;",StageDef3%);
ToolbarSet(sd4btn%,"Define &4||Adjust Stage criteria for # animal 4.   Hotkey: 4;",StageDef4%);
ToolbarSet(showbtn%,"Sho&W||Select which data to display. Hotkey: W;",Show%);

ToolbarSet(delselbtn%,"Del Sel||Delete selected channels",DelSel%);
ToolbarSet(delprocbtn%,"Del Proc||Delete all channel processes",DelProc%);
ToolbarSet(vmbtn%,"Mark &Transitions||Hotkey: T;  Show Vertical markers.",VMarkShow%);
ToolbarSet(chkbtn%,"Check sleep states||Find and hide spurious sleep stage markers",CheckSS%);
ToolbarSet(editbtn%,"&Edit sleepstates||Hotkey: E;  Change sleep states markers manually.", Edit%);
ToolbarSet(tablebtn%,"&Table||Hotkey: T;  Table of results",Report%);
ToolbarSet(gpwrbtn%,"&Gated Power||Hotkey: G;  Power spectra of identified sleep states.",GatedPower%);
ToolbarSet(prefsbtn%,"Preferences||Configure output pulses and online display",Preferences%);
ToolbarSet(resetbtn%,"Reset||Delete ALL channels created by this script",Reset%);
ToolbarSet(rbtn%,"  forward one screen|0xBE|Shift 1 screen right;  Hotkey: .(period)",RJmp%); 'Hotkeys use Virtual key codes (not ascii)
ToolbarSet(lbtn%," back one screen|0xBC|Shift 1 screen left:  Hotkey: ,(comma)",LJmp%); '
end;

func CheckSS%()   'Check sleep stage channel for anomalies
var chlst%[3],csch%,t1,t2,tst,tol:=0.001,n%,nh%,btn%,done%;
var epdur,doallflg%,yn%,onoff%,i%,hwidth;
hwidth:=(XHigh()-XLow())/2.0;

View(tvh%);
ChanList(chlst%[],"=[Ss][Tt][Aa][Gg][Ee]",32+2048);
docase
case chlst%[0]=0 then
    Newsflash("No visible <Stage> channel",30,75,5,0);
case chlst%[0]>1 then
    Newsflash("More than one visible <Stage> channel",30,75,5,0);
else
    csch%:=chlst%[1];                                   ' csch%: sleep stage channel to check channel
    epdur:=Val(ChanComment$(csch%));
    if epdur=0 then
        drandx%:=1;
        DlgCreate("Set epoch",dxra[drandx%],dyra[drandx%]); ' cope if we did not find epoch duration in the channel comment
        DlgReal(1,"Sleep stage duration (s).",5,60,0,0,1);
        DlgButton(0,"Cancel",Cancelx%);
        DlgButton(1,"OK",OKx%);
        ok%:=DlgShow(epdur);
        if ok%=0 then return 1; endif;                  ' cancelled
    endif;
    MarkMask(csch%, 0);                                 ' set mode 0
    MarkMask(csch%, -1, 1, -1);                         ' all pass
    MarkMask(csch%,0, 0,-1);                            ' exclude all codes in layer 0
    MarkMask(csch%,0,1,255);                            ' show code 255 only
    nh%:=Count(csch%,0,Maxtime());                      ' count previously hidden markers
    ' restore
    MarkMask(csch%, 0);                                 ' set mode 0
    MarkMask(csch%,-1, 1,-1);                           ' include all codes
    MarkMask(csch%,0, 0,0,255);                         ' exclude code zero and code FF (255)
    
    if nh%>0 then
        drandx%:=2;
        DlgCreate("Query",dxra[drandx%],dyra[drandx%]);
        DlgText(Print$(" %d hidden sleep stage marker(s) found in Stage channel %d\n Do you want to restore them?",nh%,csch%),1,1);
        DlgButton(1,"No||Hotkey: <Enter>",OKx%);
        DlgButton(0,"Yes",Cancelx%); 
        yn%:=Dlgshow();
        if yn%=0 then
            ReinstateAll(csch%,255);
            return 1;
        endif;
    endif;
    
    ' hide terminators
    t1:=NextTime(csch%,-1);                             ' find first
    repeat
        t2:=NextTime(csch%,t1);
        if t2<0 then break; endif;                      ' hit end of file
        tst:=t2-t1;
        if Abs(tst-epdur)>tol then                      ' found a misplaced marker
            n%+=1;
            if doallflg%=0 then
                CursorSet(1,t2);
                hwidth:=(XHigh()-XLow())/2.0;
                XRange(t2-hwidth,t2+hwidth);
                ' XRange(t2-20,t2+20);
                Sound("S!",1);  'audo warning that a glitch was detected
                btn%:=Interact("  Mis-placed sleep stage marker found.",511,0,"&Skip||Hotkey:  S; Skip to next mis-timed marker","Skip All","&Hide||Hotkey:  H;  Hide vthis marker;","Hide All"); ' hide/Restore
            endif;
            docase
            case btn%=1 then                            ' skip current marker
            case btn%=2 then doallflg%:=1;              ' loop to the end without further interaction
            case btn%=3 then DoHide(csch%,t2); nh%+=1;  ' hide and increment the count of hidden markers
            case btn%=4 then DoHide(csch%,t2); nh%+=1; doallflg%:=1; btn%:=3; ' loop to the end without further interaction
            endcase;
            
            t1:=NextTime(csch%,t2);
        else
            t1:=t2;
        endif;
    until done%;
    Message("Number of visible mis-timed sleep stage markers found:  %d.",n%);
    MarkMask(csch%,0,1,0);                              ' reinstate terminators
endcase;
return 1;
end;

proc DoHide(ch%,t)
var codes%[4];

NextTime(ch%,t-BinSize(),codes%[]);                     ' get codes of suspect marker
codes%[1]:=codes%[0];                                   ' push the original code into next level
codes%[0]:=255;                                         ' mark as suspect (this code is hidden) 
MarkSet(ch%,t-Binsize(),t+Binsize(),codes%[]);          ' apply new codes
end;

proc ReinstateAll(ch%,c%)
var codes%[4],done%;
var t:=-1;

MarkMask(ch%, 0);                                       ' set mode 0
MarkMask(ch%,-1, 1,-1);                                 ' include everything (reset)
MarkMask(ch%, 0, 0, -1);                                ' exclude everything in layer 0
MarkMask(ch%, 0, 1, c%);                                ' include selected code
repeat
    t:=NextTime(ch%,t,codes%[]);
    if t<0 then break; endif;                           ' hit end of file
    codes%[0]:=codes%[1];                               ' restore original code
    codes%[1]:=0;                                       ' clear level 1
    MarkSet(ch%,t-BinSize(),t+BinSize(),codes%[]);
until done%;
MarkMask(ch%, 0);                                       ' set mode 0
MarkMask(ch%,-1, 1,-1);                                 ' include all codes
MarkMask(ch%,0, 0,0,255);                               ' exclude code zero and code FF (255)
end;
'===========================================
func LJmp%()                                            ' Scroll left
var vh%,w;

vh%:=View();                                            ' get current view
if ViewKind(tvh%)<> 0 then return 1; endif;             ' do nothing unless we have a time view
View(tvh%);
w:=XHigh()-XLow();                                      ' jump left by one screen
XRange(XLow()-w);                                       ' shift left leaving width unchanged
if XLow()=0.0 then Sound("S*",1); endif;                ' sound if we hit the start
view(vh%);                                              ' go back to view that was current when the button was pressed
return 1;
end;

func RJmp%()                                            ' Scroll right
var vh%,w;

vh%:=View();
if ViewKind(tvh%)<> 0 then return 1; endif;
View(tvh%);
w:=XHigh()-XLow();
XRange(XLow()+w);                                       ' shift right leaving width unchanged
if XHigh()=Maxtime() then Sound("S*",1); endif;         ' sound if we hit the end
View(vh%);
return 1;
end;

func Reset%()
var chlst%[401],ok%;

View(tvh%);
drandx%:=3;
DlgCreate("Are you sure?",dxra[drandx%],dyra[drandx%]);
DlgText("Really delete, all channels except sampled waveforms, keyboard marker and Sample Text channels?",2,1);
DlgButton(0,"Cancel",Cancelx%);
DlgButton(1,"Yes",OKx%);
ok%:=DlgShow();
if ok%=0 then return 1; endif;                          ' cancelled

ChanHide(-1);                                           ' hide all
ChanList(chlst%[],"=[Ee][Ee][Gg]",1+512);               ' show eeg
ChanShow(chlst%[]);
ChanList(chlst%[],"=[Ee][Mm][Gg]",1+512);               ' and emg channels
ChanShow(chlst%[]);
ChanList(chlst%[],1+2048); 
ChanShow(chlst%[]);                                     ' show other hidden waveforms
Optimise(-1);

ChanList(chlst%[],"=[Kk]eyb",8);                        ' show keyboard marker channel, if any.
ChanShow(chlst%[]);
if ChanKind(30)=8 then ChanShow(30); endif;             ' show Sample Text mark channel if there is one.

ChanList(chlst%[],1024);  
ChanDelete(chlst%[]);                                   ' delete all hidden channels
ToolbarEnable(all%,off%);
ToolbarEnable(prefsbtn%,on%);
ToolbarEnable(quitbtn%,on%);
ToolbarEnable(newbtn%,on%);
ToolbarEnable(oldbtn%,on%);
ToolbarEnable(rrbtn%,on%);
return 1;
end;

func PrefsChnge%(item%)
var pfreq,a$,en%,en1%;                                  ' trdur,

if item%=0 then
    DlgEnable(2,-1);                                    ' focus on <OK>
    DlgVisible(0,di%[3]);                               ' en/dis-able time window related items
endif;

if DlgValue(3)>1 then                                   ' calculate train duration and pulse frequency
    pfreq:=1000.0/(DlgValue(1)+DlgValue(2));            ' pulse frequency per second
    trdur:=DlgValue(3)*(DlgValue(1)+DlgValue(2))/1000.0; ' train duration (s)
    if trdur>(sdur-0.01) then en1%:=1; else en1%:=0; endif; 
    DlgVisible(en1%,di%[3:2]);                          ' show warning message and disable <OK> if pulse train is too long.
    DlgEnable(not en1%,-1);
    
    a$:=Print$("%.1f /s;  %.2f s.",pfreq,trdur);
    DlgValue$(di%[0],a$);
    en%:=1;
endif;
DlgVisible(en%,di%[0]);
DlgEnable(en%,di%[1]);
DlgValue$(di%[2],Print$("%.1f s",sdur*DlgValue(4)));
return 1;
end;


func PChnge%(item%);
if item%=0 then
    DlgEnable(2,-1);                                    ' focus on <OK> button (so we can see current epoch duration clearly)
endif;
return 1;
end;

func Preferences%()
var ok%;
drandx%:=18;
DlgCreate("Online options",dxra[drandx%],dyra[drandx%],55);
DlgAllow(511,0,PChnge%);
DlgGroup("Epoch",1,0.9,53,1.8);
DlgText("Sleep stage duration. (s)",0,1.8);
DlgReal(6,8,5.0,30.0,0,1.8,5.0);

DlgGroup("Options",1,3.2,53,6);
DlgText("Optimise Y-Range of power in band channels every",2,4);
DlgText("s",50,4);
DlgReal(1,4,5.0,60.0,45,4);
DlgCheck(2,"Check to include EMG and EEG channels in auto-optimise.",0,5);
DlgCheck(3,"Check to optimise after \"Stage Define.\"",0,6);
DlgCheck(4,"Check to hide data from other animals during \"Stage Define.\"",0,7);
DlgCheck(5,"Show EEG power spectrum",0,8);

DlgButton(0,"Cancel",Cancelx%);
DlgButton(1,"OK",OKx%);
ok%:=DlgShow(toptim,optimchk%,sdoptchk%,sdhidechk%,pscheck%,sdur);
if ok%=0 then return 1; endif;

var now%[6];
TimeDate(now%[]);                                       ' get todays date

if nseqmx%>1e6 then nseqmx%:=0 endif;                   ' show max. nr of repeats as zero in dialog rather than huge nr of reps.
drandx%:=4;
DlgCreate("Set up Outputs",dxra[drandx%],dyra[drandx%],50);
DlgAllow(511,0,PrefsChnge%);
DlgGroup(Print$("Sleep Epoch duration: %.1f s",sdur),1,1,48,8);
DlgReal(1,"Pulse duration (ms)",1,301*1e3-1,0,2,1);
DlgReal(2,"Inter-pulse interval (ms)",0,sdur*1e3,0,3,5);
DlgText("Pulses per train.",2,4);
DlgInteger(3,15,1,1000,0,4,1);
di%[1]:=DlgText("Train freq / duration.",2,5);
DlgGroup("",32,4.7,16,1.1);
di%[0]:=DlgText("",32,5,14);
DlgInteger(4,"Nr. of trains per sequence.",1,50,0,6,1);
DlgText("Sequence duration (s).",2,7);
DlgInteger(5,"Number of sequences to apply.|Set zero for no upper limit.",0,1e6,0,8,1);
di%[2]:=DlgText("",35.5,7,10.1);

di%[4]:=DlgGroup("WARNING",1,9.5,48,2.2);             
'di%[3]:=DlgText("Pulse train is too long.\nIt must be shorter than one sleep staging epoch.",3,10.3);
DlgButton(0,"Cancel",Cancelx%);
DlgButton(1,"OK",OKx%);
ok%:=DlgShow(tpls,ipi,np%,ntr%,nseqmx%);

if ok%=0 then return 1; endif;

if nseqmx%=0 then nseqmx%:=1e7; endif;                  ' if user selected endless repetition then set 10 million reps

pls$:=Print$("%.1f,%.1f,%d,%d,%d,%d,%d",tpls,ipi,np%,ntr%,nseqmx%,sdoptchk%,sdhidechk%);
Profile(key$,"Pulses",pls$);                            ' save current pulse settings

sdur$:=Print$("%.1f",sdur);                             ' save epoch duration to profile
Profile(key$,"ep",sdur$);

trdur$:=Print$("%.1f",trdur);
Profile(key$,"skipdur",trdur$);

ToolbarEnable(newbtn%,on%);
ToolbarEnable(oldbtn%,on%);
ToolbarEnable(rrbtn%,on%);
return 1;
end;

func ChGatedPow%(item%)
var txt$,txt2$,ul,nbins%,binw;

if item%<=1 or item%=6 then                             ' EEG channel or FFT size changed
    View(tvh%);
    ul:=0.5/BinSize(DlgValue(1));                       ' half sampling rate of selected channel
    nbins%:=Val(fftlst$[DlgValue(6)])/2.0;
    binw:=ul/nbins%;
    txt$:=Print$("Result will show frequencies from 0 to %.1f Hz",ul);
    txt2$:=Print$("in %d bins of width %.3f Hz.",nbins%,binw);
    DlgValue$(txt%[0],txt$);
    DlgValue$(txt%[1],txt2$);
endif;
return 1;
end;

func GatedPower%()                                      ' generate power spectrum for selected vigilance state
var ok%,list$[6],wdw$[10],ech%,fftsz%;                  ' stg,etg,sndx%, eegchan%, sndx%, now global  (so remembered between trials)
var dupch1%,dupch2%,ttl$,pos%,powvh%,maxT,t1,t2;	    
var done%:=0,dur;
var chlst%[10],echlst%[10];

list$[0]:="All"; list$[1]:="Wake"; list$[2]:="NREM"; list$[3]:="REM"; list$[4]:="Ambig."; list$[5]:="Doubt";
wdw$[0]:="None"; wdw$[1]:="Hanning"; wdw$[2]:="Hamming"; wdw$[3]:="Kaiser 30dB";  wdw$[4]:="Kaiser 40dB"; 
wdw$[5]:="Kaiser 50dB"; wdw$[6]:="Kaiser 60dB"; wdw$[7]:="Kaiser 70dB"; wdw$[8]:="Kaiser 80dB"; wdw$[9]:="Kaiser 90dB";

View(tvh%);
ChanList(chlst%[],"=[Ee][Ee][Gg]",1+512+2048);          ' list of visible EEG channels
chlst%[0]+=4194304;                                     ' short form chan titles in the dialog
ChanList(echlst%[],"=[Ss]tage",32+2048);                ' list of visible <Stage> channels

etg:=MaxTime();
drandx%:=5;
DlgCreate("Power spectrum set up",dxra[drandx%],dyra[drandx%]);
DlgAllow(511,0,Chgatedpow%);
DlgChan(1,"Select EEG channel:",chlst%[]);              ' visible EEG channels
DlgChan(2,"Select Epoch channel:",32+2048);             ' visible textmark chans
DlgList(3,"Select vigilance state:",list$[],5);
DlgXValue(4,"Start time (s):");
DlgXValue(5,"End time (s):");
DlgList(6,"FFT size:",fftlst$[],11);
DlgList(7,"Window:",wdw$[],10);
DlgGroup("",2,8,44,2);
txt%[0]:=DlgText("",5,8.5,40);
txt%[1]:=DlgText("",15,9.2,30);

DlgButton(0,"Cancel",Cancelx%);
DlgButton(1,"OK",OKx%);
ok%:=DlgShow(eegchan%,ech%,sndx%,stg,etg,fftndx%,wdwndx%);
docase
case not ok% then return 1;
case eegchan% =0 then Newsflash("No EEG channel",0,70,10,0); return 1;
case ech% =0 then Newsflash("No Epoch marker channel",0,70,10,0); return 1;
case stg>=etg then Newsflash("Invalid time range",0,70,10,0); return 1;    
endcase;                                                ' cancelled
Yield();                                                ' close the dialog before the real work begins
ToolbarText("Generating power spectrum...");
View(tvh%);

var npts%;
npts%:=sdur/BinSize(eegchan%);                          ' (tt2-tt1)
fftsz%:=Val(fftlst$[fftndx%]);                          ' create power spectrum
if npts%<fftsz% then
	Message("Error|FFT size (%d) exceeds the number of data points per epoch (%.0f)",fftsz%,npts%); 
	return 1;
endif;
maxT:=MaxTime();
ttl$:=WindowTitle$();
pos%:=InStr(ttl$,".smr");
ttl$:=Left$(ttl$,pos%-1);
powvh%:=SetPower(eegchan%,fftsz%,wdwndx%);
WindowTitle$("Pw "+list$[sndx%]+"("+ttl$+")");
Window(0,0,40,40);
if sndx% = 0 then                                       ' process whole time range
    Process(stg,etg,0,1);                               ' process end to end
	dur:=etg-stg;                                       ' time processed
else                                                    ' process selected state
    if sndx%=4 then sndx%:=0; endif;                    ' script uses sndx%=0 for ambiguous epochs
	View(tvh%);
	dupch1%:=ChanDuplicate(ech%);                       ' copy of epoch marker channel for onset of selected state
	dupch2%:=ChanDuplicate(ech%);                       ' copy of epoch marker channel for end of selected state
	MarkMask(dupch1%, 0);                               ' set mode 0
	MarkMask(dupch1%,-1, 1,-1);                         ' include everything (reset)
	MarkMask(dupch1%, 0, 0, -1);                        ' exclude everything in layer 0
	MarkMask(dupch1%, 0, 1, sndx%);                     ' include selected stage
	MarkMask(dupch2%, 0);                               ' set mode 0
	MarkMask(dupch2%,-1, 1,-1);                         ' include everything (reset)
	MarkMask(dupch2%, 0, 0, sndx%,9,255);               ' exclude selected stage, terminator (code 9) and intentionally hidden markers
	t2:=stg-0.01;                                       ' make sure we include epoch at start time    
	repeat
		View(tvh%);
		t1:=NextTime(dupch1%,t2);                       ' onset of selected state
		if t1 >=etg then                                ' no epochs of selected type in time range
			done%:=1;                                   ' break out of the repeat loop
            if dur <=0 then
                View(powvh%);
                FileClose(0,-1);                        ' close empty power spectrum window
                Newsflash("No epochs of selected type in time range",0,0,0,1);
            endif;               
		else                                            ' process new time range
			t2:=NextTime(dupch2%,t1);                   ' end of episode in selected state
			if t2 > etg or t2 < 0 then t2:=etg; done%:=1; endif; ' stop at end of time range if it occurs within the current stage
			if t1 >= 0.0  and t1 < t2 then
				View(powvh%);
                Process(t1,t2,0,1);                     ' process current time range
				dur+=t2-t1;                             ' total time processed into power spectrum 
			else
				done%:=1;
			endif;
		endif;
	until done%;
	View(tvh%);
	ChanDelete(dupch1%);
	ChanDelete(dupch2%);
endif;
if ViewKind(powvh%)=4 then
	View(powvh%);
	XTitle$(Print$("Time range: %.2f to %.2f s. Time processed: %.1f s.",stg,etg,dur));
	XRange(0.0,35.0);
	FrontView(powvh%);
endif;
ToolbarText("");
return 1;
end;

func VMarkShow%()                                       ' add vertical marks to highlight sleep stage transitions.
var chlst%[5],sschan%,ok%;
var c1%[4],c2%[4],vmkch%;

View(tvh%);
Chanlist(chlst%[],"=[Ss][Tt][Aa][Gg][Ee]",32+2048);
docase
case chlst%[0]=0 then 
    Newsflash("No visible stage marker channel",10,75,5,0);
    return 1;
case chlst%[0]=1 then sschan%:=chlst%[1];
case chlst%[0]>1 then
    drandx%:=6;
    DlgCreate("Query",dxra[drandx%],dyra[drandx%]);
    DlgChan(1,"Sleep stage channel",32+2048+4194304);   ' select visible textmark channel + short titles
    
    DlgButton(0,"Cancel",Cancelx%);
    DlgButton(1,"OK",OKx%);
    ok%:=DlgShow(sschan%);
    if not ok% then return 1; endif;                    ' cancelled   
endcase;
MarkMask(sschan%, 0);                                   ' set mode 0
MarkMask(sschan%,-1, 1,-1);                             ' include everything (reset)
MarkMask(sschan%, 0, 0, -1);                            ' exclude everything in layer 0
MarkMask(sschan%, 0, 1, 1,2,3);                         ' include stage codes (not code 0 =Doubt and end of epoch)

ChanList(chlst%[],"=[Vv][Mm]",32);
if chlst%[0]=1 then
    ChanDelete(chlst%[1]);                              ' delete previous vmark channel
endif;
vmkch%:=MemChan(8,10);                                  ' new channel for setting position of vertical marks
ChanTitle$(vmkch%,"VM");
MemImport(vmkch%,sschan%,0,MaxTime());                  ' import all markers for start of a recognised sleep state
DrawMode(vmkch%,2);                                     ' lines mode
'ChanShow(vmkch%);
MarkMask(sschan%,-1, 1,-1);                             ' reset  original sleep stage channel
MarkMask(sschan%,0,0,255);                              ' hide code 255
'keep markers when the state changes but delete the rest
var t,t1,t2;
t:=MemGetItem(vmkch%,3);                                ' time of 3rd marker
repeat
    t1:=LastTime(vmkch%,t,c1%[]);                       ' time and codes of preceding pair of markers 
    t2:=LastTime(vmkch%,t1,c2%[]);
    docase
    case t1<0 or t2<0 then break;
    case c1%[0]=c2%[0] then
        MemDeleteTime(vmkch%,0,t1);                     ' delete marker if no change of sleep state
    endcase;
    t:=NextTime(vmkch%,t);
until t<0;
VerticalMark(vmkch%,1+2+4,0,2,0);                       ' labelled vertical marks at transitions between sleep states
vmflag%:=1;                                             ' global flag that vertical marks are on display
ToolbarClear(vmbtn%);
ToolbarSet(vmbtn%,"Hide &Transitions||Hotkey: T;  Hide Verical markers.",VMarkHide%);
return 1;
end;

func VMarkHide%()
VerticalMark(0);                                        ' hide vertical marks
vmflag%:=0;                                             ' flag that vertical marks are hidden
ToolbarClear(vmbtn%);
ToolbarSet(vmbtn%,"Mark &Transitions||Hotkey: T;  Show Vertical markers.",VMarkShow%);
return 1;
end;

func RRChnge%(item%)
if item%=0 or item%=3 then
    DlgEnable(DlgValue(3),4);                           ' disable interval if box is unchecked
endif;
return 1;
end;

func Rerun%()
FindView(tvh%,0);
if ViewKind(tvh%)<> 0 then
    tvh%:=FileOpen("",0,1,"Select file to process");
    if ViewKind(tvh%)<>0 then Newsflash("No data file.",0,75,5,1); return 1; endif;
endif;

Profile(key$,"replay","1.0,0.0",replay$);
ReadStr(replay$,rspeed,st);                             ' speed and start time
CursorSet(1,st);
drandx%:=7;
DlgCreate("Rerun settings",dxra[drandx%],dyra[drandx%],50);
DlgAllow(511,0,RRchnge%);
DlgReal(1,"Re-run speed (x0.25 to x4)",0.25,4.0,0,0,0.25);
DlgText("Start time",2,2);
DlgXValue(2,15,0,2);
DlgCheck(3,"Optimise traces periodically.");
DlgReal(4,"Optimise interval (s)",10.0,120.0,0,0,5.0);
DlgCheck(5,"Check to include EMG and EEG channels");
DlgCheck(6,"Show EEG power spectrum");

DlgButton(0,"Cancel",Cancelx%);
DlgButton(1,"OK",OKx%);
ok%:=DlgShow(rspeed,st,optimchk%,toptim,rawchk%,pscheck%);

if ok% then
    Window(0,0,75,98);
    WindowVisible(1);
    rrchk%:=1;
    XRange(st);
    replay$:=Print$("%.1f,%.1f",rspeed,st);
    Profile(key$,"replay",replay$);
    var btn%[7]:={1,5,17,18,25,28,29};
    ToolbarEnable(all%,off%);
    ToolbarEnable(btn%[],on%);
    pulsesch%:=PulsePattern%(stt,endt);    
else
    if ChanKind(pulsesch%)=4 then ChanDelete(pulsesch%); endif;
    CursorDelete(-1);
    rrchk%:=0;
endif;
return 1;
end;

func DelProc%()
var lst%[40],i%;
if ViewKind(tvh%)=0 then
    View(tvh%);
    ChanProcessClear(-1);
    ChanList(lst%[],1+512+2048);                        ' visible waveforms
    for i%:=1 to lst%[0] do
        Optimise(lst%[i%]);
    next;
    HCursorDelete(-1);
endif;
return 1;
end;

func DelSel%()
var chlst%[101],ok%;

if ViewKind(tvh%)=0 then
    View(tvh%);
    ChanList(chlst%[],1+65536);    'list of selected waveforms
    if chlst%[0]>0 then
        ok%:=Query("Selected waveform channels detected\nAre you sure you want to delete them?");
        if ok%=0 then 
            return 1;   ''cancelled
        endif;
    endif;    
    ChanDelete(-3);
    ChanList(chlst%[],"=[Ss][Tt][Aa][Gg][Ee]",32+2048);
    if chlst%[0]=0 then                                 ' no visible stage channel
        ChanList(chlst%[],"=VM",32);                    ' delete vertical marker channel if no visible stage channel
        if chlst%[0]>0 then
            ChanDelete(chlst%[1]);
        endif;
        Optimise(-1);                                   ' optimise remaining channels
    endif;
    var btn%[9]:={1,2,3,4,12,17,18,28,29};
    ToolbarEnable(all%,off%);
    ToolbarEnable(btn%[],on%);    
endif;
return 1;
end;

func SelectFile%();
FindView(tvh%,0);
if ViewKind(tvh%)<> 0 then
    tvh%:=FileOpen("",0,1,"Select file to process");
    if tvh%<0 then return 1; endif;                     ' cancelled
endif;
if ViewKind(tvh%)=0 then
    Window(0,0,75,98);
    WindowVisible(1);
    onofflineflg%:=0;                                   ' flag offline processing 
    var btn%[7]:={1,5,17,18,25,28,29};                     
    ToolbarEnable(all%,off%);
    ToolbarEnable(btn%[],on%);         
endif;
rrchk%:=0;
return 1;
end;

func SFChnge%(item%)                                    ' respond to changes in the Select File dialog
if item%<=1 then 
    DlgEnable(DlgValue(1),2,3);                         ' check box state determines whether other items are enabled      
endif;
return 1;
end;

func Idle%()
var i%,st,nd,en%,j%;

if samplestatus() = 0 and ttableflg%=1 then             ' waiting to start scheduled sampling
    Timedate(gnow%[]);                                  ' current time
    ArrSub(gnow%[],begin%[]);                           ' subtract scheduled start time
    Abs(gnow%[]);                                       ' rectify so all differences are positive
    if ArrSum(gnow%[])=0 then                           ' if differences some to zero we are ready for blast off.
        SStart%();                                      ' would fail if 1 idle cycle took more than 1s -v.unlikely!
    endif;
endif;

if SampleStatus()=2 and ttableflg% then                 ' scheduled recording underway...
    if View(tvh%).Maxtime()>rdursec% then 
        SStop%();                                       ' end scheduled recording when time's up.
    endif;
endif;

if SampleStatus()=2 or rrflg% then                      ' if sampling or rerunning underway then... 
    View(tvh%);
    if rrflg% then nd:=PlayOffline(0)-twin; else nd:=MaxTime()-Max(leeway,twin); endif; ' leeway for fft block or Smooth process 
    if nd<=0 then return 1; endif;                      ' do nothing until we have some data
    for j%:=0 to nchk%-1 do
        st:= LastTime(thetach%[j%],MaxTime());
        ChanSave(vthetach%[j%],thetach%[j%],0,st,nd);   ' save banded power to permanent channels (1 FFT block behind)
        ChanSave(vdeltach%[j%],deltach%[j%],0,LastTime(deltach%[j%],MaxTime()),nd);
        ChanSave(vtdch%[j%],tdch%[j%],0,LastTime(tdch%[j%],MaxTime()),nd);
        for i%:=0 to 1 do
            if udbndchk%[i%] then                       ' append recent data to disk-based user-defined band channels
                ChanSave(vudbndch%[i%][j%],udbndch%[i%][j%],0,LastTime(udbndch%[i%][j%],MaxTime()),nd);   
            endif;
        next;
    next;
    
    StageMkrOnline%(ssch%[][:nchk%],sdur,nd);
    
    if SampleStatus()=2 and ttableflg% and twdone%=0 then ' if scheduled sampling then enable stimulation at selected time
        if View(tvh%).MaxTime()<stimonsec% then         ' if target time not reached yet
            stimflag%:=0;                               ' disable stimulation
        else
            stimflag%:=1;                               ' else enable stimulation
            twdone%:=1;                                 ' flag to ensure that time window criterion operates once only
            MemSetItem(vmch%,0,MaxTime()-BinSize(),1,"Stim ON");
            ChanShow(vmch%,1);
            DrawMode(vmch%,15,0);                       ' States mode
            ChanOrder(0,-1,vmch%);                      ' at top of window  
        endif;
    else
        if twdone%=0 then
            stimflag%:=1;                               ' enable stimulation if time window switched off
        endif;
    endif;
    
    if SampleStatus()=2 and ttableflg%=1 and stimflag%=1 then ' if sampling, scheduled recording and stimulation ON
        if View(tvh%).MaxTime()>=stimoffsec% then       ' if scheduled end of stimulation reached
            stimflag%:=0;
            MemSetItem(vmch%,0,MaxTime()-BinSize(),0,"Stim OFF");
        endif;        
    endif;
    
    if stimflag% then                                   ' do output pulses if enabled and timing criteria are met
        if rrflg% then
            PulseOutReRun%(nd)
        else
            PulseOut%(nd);                              ' set pulses for all selected animals
        endif;
    endif;
    
    if dlgopenflg%=0 then                               ' lock hcursors unless Stage define dialog is open
        for i%:=1 to 6 do
            if HCursorExists(hc%[i%]) then
                if HCursor(hc%[i%])<>lasthc[i%] or HCursorChan(hc%[i%])<>lasthcch%[i%-1] then
                    HCursor(hc%[i%],lasthc[i%],lasthcch%[i%-1]); ' lock cursors at their last known position
                endif;
            endif;
        next;
    endif;
    
    if Seconds()> toptim then       
        for j%:=0 to nchk%-1 do
            if optimchk% then
                Optimise(Print$("%d,%d",eegch%[j%],emgch%[j%])); ' include sampled channels if checkbox checked
                YRange(emgch%,0.0,YHigh(emgch%[j%]));
            endif;
            Optimise(Print$("%d,%d,%d,%d,%d",thetach%[j%],deltach%[j%],tdch%[j%],udbndch%[0][j%],udbndch%[1][j%])); ' optimise band channels at interval of toptim(s)
            for i%:=0 to 3 do
                YRange(ssch%[i%][j%],0,1.1);
            next;
            YRange(thetach%[j%],0.0,YHigh(thetach%[j%]));
            YRange(deltach%[j%],0.0,YHigh(deltach%[j%]));
            YRange(tdch%[j%],0.0,YHigh(tdch%[j%]));
            for i%:=0 to 1 do
                if ChanKind(udbndch%[i%][j%])= 9 then
                    YRange(udbndch%[i%][j%],0.0,YHigh(udbndch%[i%][j%]));
                endif;
                Yield();
            next;
        next;        
        Seconds(0);
    endif;      
endif;

if ViewKind(tvh%)<>0 then FindView(tvh%,0); endif;
if SampleStatus()=-1 and rrchk%=0 and ViewKind(tvh%)=0 then ' enable buttons if time view and not sampling or re-running
    en%:=1;
endif;
var btn%[10]:={17,18,20,21,22,23,24,26,28,29};
ToolbarEnable(btn%[],en%);                              ' reset,gated pwr,edit,table,vertmkr,delsel and delproc buttons
return 1;
end;

func PulseOutReRun%(now)
var code%[4],t,j%;

View(tvh%);
for j%:=0 to nchk%-1 do                                 ' for each animal in turn do...
    if opchk%[j%] then                                  ' if outputs selected for this animal then...
        t:=LastTime(dupssch%[j%],now,code%[]);          ' time and type of most recent sleep state
        if t > lastpo and now> trfr[j%] and nseq%[j%] < nseqmx% and code%[0]=ss%[j%] then ' if a new epoch started and max count not reached
            ok%:=ChanSave(pulsesch%,opch%[j%],0,stt,endt,t+sdur+0.1); ' add pulse train
            nseq%[j%]+=1;                               ' increment count of sequences done
            trfr[j%]:=now +trefract[j%]+sdur;
        endif;
    endif;    
next;
lastpo:=t;                                              ' do not repeat until start of a new epoch    
return 1; 
end;

func PulseOut%(now)                                     ' generate output pulses when selected criteria are met
var code%[4],t,j%;                                      
var op%[4]:={256,512,1024,2048};                        ' code to enable digital outputs 0 to 3
var op$[4];  ArrConst(op$[],"OFF");                     ' toolbar indicator for pulses ON or OFF.
var pr$;

View(tvh%);
'vdigout%:=0;                                            ' reset for next epoch
for j%:=0 to nchk%-1 do                                 ' for each animal in turn do...
    if opchk%[j%] then                                  ' if outputs selected for this animal then...
        t:=LastTime(dupssch%[j%],now,code%[]);          ' time and type of most recent sleep state
        'if t > lastpo then                              ' if a new epoch started and max count not reached
        docase                                              'ANNE EDIT: comment this whole case out in order that the third case (stimulus already on but sleep stage code no longer correct) can be activated
        case pulseon%[j%]=1 and now < pulse_end[j%] then                    ' stimulus already on and sequence not finished yet
            'Yield(); 
            vdigout%:=vdigout%;                      ' continue stimulation as before AV added: may not be necessary           
            
        case pulseon%[j%]=1 and now > pulse_end[j%] then                    ' stimulus already on and sequence not finished yet
            'Yield();                               'AV added: now > pulse_end[j%] so that it can tell when the pulse is supposed to end
            vdigout%-=op%[j%];                      ' disable this digital output for current epoch
            op$[j%]:="OFF";
            pulseon%[j%]:=0;
            trfr[j%]:=now+trefract[j%];                 ' end time of the refractory period of this stimulus sequence
            ToolbarText(Print$("Onset of current stage:   %.1fs,   Animal %d refractory period ends at:  %.1fs",now,shw%+1,trfr[j%]));
            
'        case pulseon%[j%]=1 and now < pulse_end[j%] and (code%[0]<ss%[j%] or code%[0]>ss%[j%]) then      ' AV added: stimulus already on and sleep stage code no longer correct
'            'Yield();            
'            vdigout%-=op%[j%];                      ' disable this digital output for current epoch
'            op$[j%]:="OFF";
'            pulseon%[j%]:=0;
'            trfr[j%]:=now+trefract[j%];                 ' end time of the refractory period of this stimulus sequence
'            'PrintLog(j%, trfr[j%]);
'            ToolbarText(Print$("Onset of current stage:   %.1fs,   Animal %d refractory period ends at:  %.1fs",now,shw%+1,trfr[j%]));
            
        case pulseon%[j%]=0 and code%[0]=ss%[j%] and now> trfr[j%] and nseq%[j%] < nseqmx% then ' start new series of pulses on this output
            ' if: no stimulus underway, stage code detected and outside refractory period of previous stimulus and max count not reached yet...
            'Yield();
            vdigout%+=op%[j%];                      ' enable this digital output for current epoch
            pulseon%[j%]:=1;
            nseq%[j%]+=1;                           ' increment count of sequences done
            op$[j%]:="ON";
            pulse_end[j%]:= now + tpls/1000.0;      ' AV added: time stimulus should end
            PrintLog("start stim: %d, j%: %d, pulse_end: %d \n",now, j%, pulse_end[j%]);
            
        else
            'Yield();            
            vdigout%:=vdigout%;             'AV added: may not be necessary
            'PrintLog("vdigout: %d\n",vdigout%);
        endcase;
        
    endif;
    'endif;    
next;
'if vdigout%>0 and t>lastpo then
'PrintLog("vdigout: %d\n",vdigout%);
if vdigout%>=0 then                                     ' AV edit: enables vdigout% whether it is 0 or over
    'Yield();
    SampleSeqVar(4,vdigout%);                           ' enable the required digital outputs for the new epoch
    SampleKey("x");
endif;
if t>lastpo then
    if ttableflg% then 
        pr$:=Print$("  Stimulation ends: %s (%s)",sttime2$,stdate2$);
    else
        pr$:= "  ";
    endif;    
    ToolbarText(Print$("%s  Pulse outputs :  1: %s; 2: %s; 3: %s; 4: %s",pr$,op$[0],op$[1],op$[2],op$[3])); ' report currently active outputs on the toolbar
endif;

'for j%:=0 to nchk%-1 do                                 ' for each animal in turn do...            
'    if pulseon%[j%] and t>lastpo then                
'        ntrains%[j%] +=1;                               ' one more train done
'        if ntrains%[j%]=ntr% then                       ' if all done this turn pulses off
'            ntrains%[j%]:=0;
'            pulseon%[j%]:=0;
'            trfr[j%]:=now+trefract[j%];                 ' end time of the refractory period of this stimulus sequence
'            'CursorSet(1,now);
'            ToolbarText(Print$("Onset of current stage:   %.1fs,   Animal %d refractory period ends at:  %.1fs",now,shw%+1,trfr[j%]));
'        endif;
'    endif;                
'next;
lastpo:=t;                                              ' do not repeat until start of a new epoch
return 1;
end;

func PulsePattern%(&st,&et)
'create a single copy of the output pulse pattern in a memory buffer
'et:  the end time of the pulse pattern
'returns: memory buffer containing the patterned pulses.
var ch%,i%,j%,t;
var ipis:=ipi*0.001;                                    ' inter pulse interval (s)
var tplss:=tpls*0.001;

st:=0.1;
View(tvh%);

ch%:=MemChan(4,0,0);                                    '  'level memory buffer

for j%:=1 to ntr% do
    t:=st;
    for i%:=1 to np% do
        MemSetItem(ch%,0,t);                            ' pulse onset
        t+=ipis;
    next;
    
    t:=st+tplss;                                        ' end time of pulses
    for i%:=1 to np% do
        MemSetItem(ch%,0,t);                            ' pulse onset
        t+=ipis;
    next;
    st+=sdur;
next;
st:=0.1;
et:=LastTime(ch%,MaxTime()+1)+Binsize();                ' time at end of sequence
ChanTitle$(ch%,"pulses");
'ChanShow(ch%);
return ch%;
end;

func PulseOutOffline%(j%,pulsesch%,st,et)               ' create predicted pulse output channel for current animal
var t0:=-1,t1,code0%[4],code1%[4],val,tlast,done%:=0;
var ok%,stssm%,ftdpo%[6];
var secperday%:=3600*24;

View(tvh%);
MarkMask(sstatech%[j%], 0);                             ' set mode 0
MarkMask(sstatech%[j%],-1, 1,-1);                       ' include everything (reset)
MarkMask(sstatech%[j%], 0, 0, 9,255);                   ' exclude code 9 and 255 layer 0   (terminators+ intentionally hidden markers)

FileTimeDate(ftdpo%[]);
stssm%:=ftdpo%[0]+ftdpo%[1]*60+ftdpo%[2]*3600+(ftdpo%[3]-1)*secperday%;
if ftdpo%[4]>1 then                                     ' add in seconds from previous months
    var tt%;
    tt%:=ArrSum(sperm%[:ftdpo%[4]-1]);
    if ftdpo%[4] mod 4 =0 then tt%+=secperday%; endif;  ' add in leap year
    stssm%+=tt%;                                        ' start time in sec since start of year
endif;

twdone%:=0;                                             ' reset time window flag for next animal
repeat    
    t0:=NextTime(sstatech%[j%],t0,code0%[]);   
    t1:=NextTime(sstatech%[j%],t0,code1%[]);
    if t0 <0 or t1<0 then break endif;                  ' break out of loop when we hit the end of the file
    tlast:=LastTime(opch%[j%],t1+BinSize(),val);        ' time of last transition hi/lo or vv.
    
    if code0%[0]=ss%[j%]  and val=1 and (t1-tlast) > trefract[j%] then ' and code1%[0]=ss%[j%]
        ok%:=ChanSave(pulsesch%,opch%[j%],0,st,et,t1+0.1); ' add pulse train
    endif;
    
    if code0%[0]=ss%[j%] and code1%[0]=ss%[j%] and val=0 and tlast<0 then ' special case for first pulse train in file
        ' two successive matching state codes  + pulse lo + not in refractory period of previous pulse
        ok%:=ChanSave(pulsesch%,opch%[j%],0,st,et,t1+0.1); ' add pulse train
    endif;   
until done%;
MarkMask(sstatech%[j%],-1, 1,-1);                       ' include everything (reset)
MarkMask(sstatech%[j%],0,0,255);
ChanSelect(opch%[j%],1);                                ' exclude inentionally hidden(code 255)
return 1;
end;

func SaveMChan%(chmask%,inttl$)                         ' find chanel in current time view by type and title and save to disk chan
var chlst%[10],newch%,vh%;                              ' delete the original

vh%:=View();
if ViewKind(vh%)<>0 then
    Newsflash("Current view not a time view",0,75,5,0);
    return -1;
endif;
ChanList(chlst%[],"="+inttl$,chmask%);                  ' check for unsaved <Stage> marker channel
if chlst%[0]>0 then
    newch%:=ChanSave(chlst%[1],0);
    if newch%>0 then
        if ChanVisible(chlst%[1])=1 then
            ChanShow(newch%);
            ChanOrder(chlst%[1],-1,newch%);             ' keep same channel order
        else
            ChanHide(newch%);
        endif;
        if VerticalMark(-1)=chlst%[1] then
            VerticalMark(newch%);
        endif;
        ChanDelete(chlst%[1]);
        ChanSelect(newch%,1);
        View(tvh%);
    endif;
else
    return -1;
endif;
return newch%;
end;

func Quit%()
var ch%,i%;

if ViewKind(tvh%)=0 then
    View(tvh%);
    docase
    case SampleStatus()=2 then
        SStop%();
    case PlayOffline(0)>0 then
        if ViewKind(tvh%)=0 then
            View(tvh%);
            PlayOffline(-1);                            ' stop rerun
        endif;
    endcase;
    for i%:=0 to nchk%-1 do
        View(tvh%);
        ch%:=SaveMchan%(1+32+4096+16384,Print$("Stage\\(%d\\)",i%+1));
        ch%:=SaveMchan%(4+4096+16384,Print$("Pred \\(%d\\)",i%+1));
    next;
    
    ch%:=SaveMchan%(32,"VM");                           ' only one VM channel
    if ch%>0 then
        ChanHide(ch%);                                  ' hide vertical marker channel Vertical marks unaffected)
    endif;
    
    ch%:=SaveMchan%(32,"Stim on");                      ' vertical mark channel for onset of scheduled recording
    if ch%>0 then
        ChanHide(ch%);                                  
    endif;
endif;
if ChanKind(pulsesch%)= 4 then ChanDelete(pulsesch%); endif; ' delete channel containing pulse pattern if present
'else it would be left behind if user pressed ReRun followed by Quit.

if stagedefineflg% then
    drandx%:=8;
    DlgCreate("Query",dxra[drandx%],dyra[drandx%]);
    DlgText("Save sleep stage definitions?",2,1);
    
    DlgButton(0,"No",Cancelx%);
    DlgButton(1,"Yes",OKx%);
    ok%:=DlgShow();
    if ok%=1 then
        ssparams1$:=Print$("%d,%d,%d,%d,%d,%d",ssdefch1%[0][0],ssdefch1%[1][0],ssdefch1%[2][0],ssopndx1%[0][0],ssopndx1%[1][0],ssopndx1%[2][0]);
        ssparams1b$:=Print$("%d,%d,%d,%d,%d,%d",ssdefch1%[0][1],ssdefch1%[1][1],ssdefch1%[2][1],ssopndx1%[0][1],ssopndx1%[1][1],ssopndx1%[2][1]);        
        ssparams1c$:=Print$("%d,%d,%d,%d,%d,%d",ssdefch1%[0][2],ssdefch1%[1][2],ssdefch1%[2][2],ssopndx1%[0][2],ssopndx1%[1][2],ssopndx1%[2][2]);        
        ssparams1d$:=Print$("%d,%d,%d,%d,%d,%d",ssdefch1%[0][3],ssdefch1%[1][3],ssdefch1%[2][3],ssopndx1%[0][3],ssopndx1%[1][3],ssopndx1%[2][3]);        
        
        ssparams2$:=Print$("%.3f,%.3f,%.3f,%d,%d,%d",sslvl1[0][0],sslvl1[1][0],sslvl1[2][0],pchndx%[0][0],pchndx%[1][0],pchndx%[2][0]);
        ssparams2b$:=Print$("%.3f,%.3f,%.3f,%d,%d,%d",sslvl1[0][1],sslvl1[1][1],sslvl1[2][1],pchndx%[0][1],pchndx%[1][1],pchndx%[2][1]);        
        ssparams2c$:=Print$("%.3f,%.3f,%.3f,%d,%d,%d",sslvl1[0][2],sslvl1[1][2],sslvl1[2][2],pchndx%[0][2],pchndx%[1][2],pchndx%[2][2]);        
        ssparams2d$:=Print$("%.3f,%.3f,%.3f,%d,%d,%d",sslvl1[0][3],sslvl1[1][3],sslvl1[2][3],pchndx%[0][3],pchndx%[1][3],pchndx%[2][3]);        
        
        ssparams3$:=Print$("%d,%d,%d,%.3f,%.3f,%.3f",ssopndx2%[0][0],ssopndx2%[1][0],ssopndx2%[2][0],sslvl2[0][0],sslvl2[1][0],sslvl2[2][0]);
        ssparams3b$:=Print$("%d,%d,%d,%.3f,%.3f,%.3f",ssopndx2%[0][1],ssopndx2%[1][1],ssopndx2%[2][1],sslvl2[0][1],sslvl2[1][1],sslvl2[2][1]);        
        ssparams3c$:=Print$("%d,%d,%d,%.3f,%.3f,%.3f",ssopndx2%[0][2],ssopndx2%[1][2],ssopndx2%[2][2],sslvl2[0][2],sslvl2[1][2],sslvl2[2][2]);        
        ssparams3d$:=Print$("%d,%d,%d,%.3f,%.3f,%.3f",ssopndx2%[0][3],ssopndx2%[1][3],ssopndx2%[2][3],sslvl2[0][3],sslvl2[1][3],sslvl2[2][3]);        
        
        ssparams4$:=Print$("%d,%d,%d,%d",sschk%[0][0],sschk%[1][0],sschk%[2][0],opchk%[0]);
        ssparams4b$:=Print$("%d,%d,%d,%d",sschk%[0][1],sschk%[1][1],sschk%[2][1],opchk%[1]);        
        ssparams4c$:=Print$("%d,%d,%d,%d",sschk%[0][2],sschk%[1][2],sschk%[2][2],opchk%[2]);        
        ssparams4d$:=Print$("%d,%d,%d,%d",sschk%[0][3],sschk%[1][3],sschk%[2][3],opchk%[3]);        
        
        pulseparams$:=Print$("%d,%d,%d,%d,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,\"%s\",\"%s\"",ssndx%[0],ssndx%[1],ssndx%[2],ssndx%[3],trefract[0],trefract[1],trefract[2],trefract[3],pcscored,pcambig,ss$[0],ss$[4]);
        Profile(key$,"ssdef1",ssparams1$);
        Profile(key$,"ssdef1b",ssparams1b$);        
        Profile(key$,"ssdef1c",ssparams1c$);       
        Profile(key$,"ssdef1d",ssparams1d$);        
        
        Profile(key$,"ssdef2",ssparams2$);
        Profile(key$,"ssdef2b",ssparams2b$);        
        Profile(key$,"ssdef2c",ssparams2c$);        
        Profile(key$,"ssdef2d",ssparams2d$);        
        
        Profile(key$,"ssdef3",ssparams3$);
        Profile(key$,"ssdef3b",ssparams3b$);        
        Profile(key$,"ssdef3c",ssparams3c$);        
        Profile(key$,"ssdef3d",ssparams3d$);        
        
        Profile(key$,"ssdef4",ssparams4$);
        Profile(key$,"ssdef4b",ssparams4b$);        
        Profile(key$,"ssdef4c",ssparams4c$);        
        Profile(key$,"ssdef4d",ssparams4d$);        
        
        Profile(key$,"pulse",pulseparams$);        
    endif;
endif;
misc$:=Print$("%.1f,%d,%d,%d",toptim,optimchk%,pscheck%,rawchk%); ' save auto-optimisation and spectrum parameters to registry every time
Profile(key$,"misc",misc$);

'start here
blockdur$:=Print$("%.1f",blockdur);
Profile(key$,"table",blockdur$);
ok%:=FileSaveAs(relpath$+cfg$,6,1);                     ' rootpath$+ save sampling config. (e.g App. window size and position etc.)
return 0;
end;

func NewFile%()
var ok%;

ttableflg%:=0;

if ViewKind(tvh%)=0 then                                ' close pre-existing window (opportunity to save if required)
    View(tvh%);
    FileClose();
endif;

'========================================================================================
'load sampling configuration	                         'comment these lines to use the current sampling configuration
FilePathSet(relpath$,0);
drandx%:=0;
DlgCreate("Sampling Configuration",75,5);
DlgAllow(511);
DlgText(cfg$,2,1);
DlgButton(2,"Browse",CfgBrowse%);
DlgButton(0,"Cancel",Cancelx%);
DlgButton(1,"OK",OKx%);
ok%:=Dlgshow(cfg$);
if ok%=0 then return 1; endif;                          ' cancelled
PrintLog((SampleConfig$(3)));                     'ANNE edit: print config file to log

ok%:=SampleSequencer(relpath$+seq$);                    
if ok%<0 then
    Message("Error|Failed to load the sequence file: %s",seq$);
    halt;
endif;
SampleSeqCtrl(2);  

'===========================================================modified after AV
drandx%:=9;
DlgCreate("Recording mode",dxra[drandx%],dyra[drandx%]);
DlgAllow(511);
DlgText("Scheduled recording or manual control?",2,1);

DlgButton(0,"Cancel",Cancelx%);
DlgButton(1,"Manual",OKx%);
DlgButton(2,"Scheduled");
ok%:=DlgShow();
docase
case ok%=0 then return 1;                               ' cancelled
case ok%=1 then ttableflg%:=0                           ' manual control
case ok%=2 then                                         ' scheduled
    rdursec%:=RecSchedule%();
    if rdursec%=0 then
        Newsflash("Scheduled recording was cancelled.",2.5,75,5,0);
        return 1;
    endif;
    ttableflg%:=1;
endcase;
'===========================================================

tvh%:=FileNew(0,0);                                     ' ignore resources; hide initially
if tvh%<0 then
    Message(Error$(tvh%));                              ' failed to open a file
    return 1;
endif;
Window(0,0,75,97,1);                                    ' full screen but not maximised
XRange(-1,60.0);                                        ' time range +scrolling
XAxisStyle(3, 0, 0);                                    ' axis as 'time of day'
XAxisAttrib(0);                                         ' linear axis
WindowVisible(1);
onofflineflg%:=1;                                       ' flag online processing
rrchk%:=0;                                              ' not rerunning
if ttableflg% then
    vmch%:=MemChan(8,20);                               ' channel for vertical markers at start and end of scheduled stimulation
    ChanTitle$(vmch%,"Stim on");
    VerticalMark(vmch%,1+2+4,0,0,0);
endif;
var btn%[8]:={1,5,15,17,18,25,28,29};                   ' setup%,quit,delsel,delproc,sabort
ToolbarEnable(all%,off%);
ToolbarEnable(btn%[],on%);
return 1;
end;

func SStop%()
var newch%,chlst%[2],i%,j%;

docase
case onofflineflg%=1 then                               ' online
    SampleKey("z");                                     ' TTL low
    SampleStop();
    ToolbarText("");
    View(LogHandle());                                      'ANNE: to name and save log file
    FileSaveAs(samp_dir$ + "\ " + samp_name$+ "_log.txt");    
    
case rrchk%=1 then                                      ' rerun 
    View(tvh%);
    PlayOffline(-1);
    rrflg%:=0;                                          ' turn off idle processing
    rrchk%:=0;                                          ' flag rerrun over
    if ChanKind(pulsesch%)=4 then ChanDelete(pulsesch%); endif; ' delete pulse template channel
endcase;

for i%:=0 to nchk%-1 do
    if ViewKind(pvh%[i%])=4 then                        ' close power spectra if present.
        View(pvh%[i%]);
        FileClose(0,-1);
    endif;
next;

View(tvh%);
for j%:=0 to nchk%-1 do
    ChanDelete(Print$("%d,%d,%d",vthetach%[j%],vdeltach%[j%],vtdch%[j%])); ' delete virtual channels -we have disk-based copies
    for i%:=0 to 1 do
        if udbndchk%[i%] then
            ChanDelete(vudbndch%[i%][j%]);              ' delete user-defined channel(s)
        endif;      
    next;
next;
ChanDelete(Print$("%d,%d,%d,%d",dupssch%[0],dupssch%[1],dupssch%[2],dupssch%[3])); ' delete hidden duplicate of sleep stage channel -if it exists.   

for j%:=0 to nchk%-1 do
    ChanList(chlst%[],Print$("=[Ss]tage\\(%d\\)",j%+1),32+2048+4096+16384); ' visible textmark memory buffer not a duplicate called <stage[...]>
    if chlst%[0]>0 then
        newch%:=ChanSave(chlst%[1],0);                  ' save sleep stage marker to permanent channel
        ChanShow(newch%);
        ChanOrder(chlst%[1],-1,newch%);
        Yield();
        ChanDelete(chlst%[1]);
        sstatech%[j%]:=newch%;
        ChanSelect(sstatech%[j%],1);
    endif;
next;    
ToolbarClear(samplebtn%);
ToolbarSet(samplebtn%,"&Start||Hotkey: S;  Start sampling",SStart%);

var btn%[4]:={8,9,10,11};
ToolbarEnable(btn%[],off%);                             ' disable define buttons

ToolbarEnable(samplebtn%,off%);
ToolbarEnable(sabortbtn%,off%);
return 1;
end;

func ChanSetUp%()
var ok%,i%,j%;                                          
var emgchlst%[10],eegchlst%[10];
var xp,yp,itm%:=1;

onchk%[0]:=1;

FindView(tvh%,0);
if ViewKind(tvh%)<>0 then Message("not a time view."); halt; endif;
ChanList(eegchlst%[],"=[Ee][Ee][Gg]",1+512+131072);     ' list of EEG channels (short form titles)
ChanList(emgchlst%[],"=[Ee][Mm][Gg]",1+512);            ' list of EEG channels
nfound%:=Min(eegchlst%[0],emgchlst%[0]);                ' number of possible emg/eeg pairs found
if nfound%=0 then
    Message("Error|No pairs of EMG and EEG channels found in this file.");
    return 1;
endif;
eegchlst%[0]+=4194304;                                  ' short form titles
emgchlst%[0]+=4194304;

drandx%:=10;
var yy:=dyra[drandx%];
DlgCreate("Channel Setup",dxra[drandx%],dyra[drandx%]);          '    Print$("x: %.1f; y:=%.1f",dxra[drandx%],dyra[drandx%])
DlgAllow(511,0,ChanSetChnge%);
yp:=1;
for i%:=1 to 4 do
    DlgGroup("Animal: "+Str$(i%),1,yp,50,3.1);
    yp+=3.5;
next; 
yp:=2;
for i%:=1 to 4 do
    DlgCheck(itm%,"ON",2,yp);
    itm%+=1;
    yp+=3.5;
next;
yp:=2; j%:=0;
for i%:=1 to 4 do
    dt%[j%]:=DlgText("EEG channel",12,yp);  j%+=1;
    dt%[j%]:=DlgText("EMG channel",12,yp+1); j%+=1;
    yp+=3.5;
next;
yp:=2;
for i%:=1 to 4 do
    DlgChan(itm%,24,eegchlst%[],xp,yp);
    itm%+=1;
    yp+=3.5;
next;
yp:=3;
for i%:=1 to 4 do
    DlgChan(itm%,24,emgchlst%[],xp,yp);
    itm%+=1;
    yp+=3.5;
next;

xp:=25; yp:=1.6;
for i%:=1 to 8 do 
    dg%[i%-1]:=DlgGroup("",xp,yp,25,1.1);
    if i% mod 2= 0 then yp+=2.5; else yp+=1; endif;
next;
DlgButton(0,"Cancel",Cancelx%);
DlgButton(1,"OK",OKx%);
ok%:=DlgShow(onchk%[],eegch%[],emgch%[]);
if ok% then
    ToolbarEnable(setupbtn%,on%);                       ' enable banded power set up
    ' re-order channels
    nchk%:=ArrSum(onchk%[]);                            ' count number of animals to process
    if nchk%<4 then
        ArrSort(onchk%[],1,eegch%[],emgch%[]);          ' sort enabled items to the top
        ArrConst(eegch%[nchk%:],0);                     ' for clarity set "switched off" channels to zero
        ArrConst(emgch%[nchk%:],0);
    endif;
    
endif;       
return 1;
end;

func ChanSetChnge%(item%)
var i%,ofs%,ra%[4],n%;

docase
case item%=0 then
    for i%:=(nfound%+1) to 4 do
        DlgValue(i%,0);
        DlgEnable(0,i%);                                ' uncheck and disable checkboxes when no data available
    next;
    
    for i%:=1 to 4 do
        DlgVisible(DlgValue(i%),i%+4,i%+8);             ' initial set up
        ofs%:=(i%-1)*2;
        DlgVisible(not DlgValue(i%),dg%[ofs%:2]);
        DlgEnable(DlgValue(i%),dt%[ofs%:2]);
    next;
case item%>0 and item%<5 then
    DlgVisible(DlgValue(item%),item%+4,item%+8);        ' user changes
    ofs%:=(item%-1)*2;
    DlgVisible(not DlgValue(item%),dg%[ofs%:2]);
    DlgEnable(DlgValue(item%),dt%[ofs%:2]);
endcase;

'Make sure that we have not selected the same channel more than once (test EEG chans first)
DlgEnable(0,-1);
var doneflg%:=0,j%;
ofs%:=4;
for j%:=1 to 2 do
    for i%:=1 to 4 do
        if DlgValue(i%) then
            ra%[i%-1]:=DlgValue(i%+ofs%);               ' insert chan nr. of enabled channels into an array
            n%+=1;                                      ' count of checked boxes
        endif;    
    next;
    docase
    case n%=0 then DlgEnable(0,-1);                     ' no animals enabled
    case n%=1 then DlgEnable(1,-1);                     ' 1 animal enabled so no possible duplication
    case n%>1 then                                      ' we need to check for duplicates
        ArrSort(ra%[],1);                               ' sort descending
        resize ra%[n%];
        ArrSort(ra%[]);                                 ' sort ascending
        ArrDiff(ra%[]);                                 ' differentiate and look for zeroes (duplicate channels)
        for i%:=1 to n%-1 do
            if ra%[i%]=0 then                           ' duplicate found
                DlgEnable(0,-1);                        ' disable <OK>
                doneflg%:=1;                            ' flag break from loop
                break;
            else
                DlgEnable(1,-1);
            endif;                                      ' disable OK button if channel selections are invalid.
        next;
        resize ra%[4];                                  ' reset arry before checking emg channels
        ArrConst(ra%[],0);
    endcase;
    if doneflg% then
        break;
    else
        ofs%+=4;                                        ' repeat for emg channels
        n%:=0;                                          ' reset counter        
    endif;
next;
return 1;
end;

func SetUpChnge%(item%)
var en%,i%;

if item%<=1 then                                        ' do rms of selected emg channels
    for i%:=0 to nchk%-1 do
        ChanProcessClear(emgch%[i%],-1);
        ChanProcessAdd(emgch%[i%],8,DlgValue(1));       ' rms amplitude process  for each emg
        Optimise(emgch%[i%]);
        YRange(emgch%[i%],0.0,YHigh(emgch%[i%]));
    next;
endif;   

if item%=0 then                                         ' or item%=2
    for i%:=0 to nchk%-1 do
        ChanProcessClear(eegch%[i%],-1);
        ChanProcessAdd(eegch%[i%],6,1.0/512,0);         ' interpolate EEG channel to sample rate of ca. 512Hz
        twin:=fftsz%*BinSize(eegch%[i%]);               ' calculate fft blocksize (s);
        stepsz:=Ceil(1000.0/twin)*0.001;                ' round frequency step size up to 3 decimal places
    next;
endif;

if item%=10 or item%=0 then                             ' enable/disable custom bands according to state of check box
    en%:=DlgValue(10);
    DlgEnable(en%,6,8,12);  
endif;

if item%=11 or item%=0 then
    en%:=DlgValue(11);
    DlgEnable(en%,7,9,13);     
endif;
return 1;
end;

func BPSetUp%()                                         ' set up banded power channels
var ok%,i%,j%,emgchlst%[10],eegchlst%[10];
var dummych%;
var dlst%[2],a$;
var bnd$[3]:={"Delta","Theta","T:D "};     
var redoflg%;

if ViewKind(tvh%)<>0 then
    Newsflash("Time view not found",4,0,0,1);
    return 1;
endif;
View(tvh%);
ChanList(emgchlst%[],"=[Ee][Mm][Gg]",1+512+2048);       ' visible waveforms with emg in title
if emgchlst%[0]=0 then
    Message("No visible waveform channels with <emg> in the title");
    return 1;
endif;

ChanList(eegchlst%[],"=[Ee][Ee][Gg]",1+512+2048);       ' visible waveforms with eeg in title
if eegchlst%[0]=0 then
    Message("No visible waveform channels with <eeg> in the title");
    return 1;
endif;
'===

if onofflineflg%=0 then                                 ' if offline then we have option to use existing eeg power channels
    ' rather than re-creating them (time-consuming for large files)
    for i%:=0 to nchk%-1 do
        for j%:=0 to 2 do
            a$:=Print$("=%s\\(%d\\)",bnd$[j%],eegch%[i%]); ' get title of power channel for each eeg channel selected in SetUp dialog
            ChanList(dlst%[],a$,512+2097152);           ' do we have already a real wave channel with this title?
            docase
            case j%=0 and  dlst%[0]=1 then              ' found one
                deltach%[i%]:=dlst%[1];                 ' use it
            case j%=1 and  dlst%[0]=1 then              ' found one
                thetach%[i%]:=dlst%[1];
            case j%=2 and  dlst%[0]=1 then              ' found one
                tdch%[i%]:=dlst%[1];            
            else
                redoflg%:=1;                            ' not found so we have to re-make all the power in band channels
                break;
            endcase;
            if redoflg%=1 then break; endif;            ' one missing channel  so no point in continuing...
        next;    
    next;
    if redoflg%=0 then                                  ' option to use existing channels
        drandx%:=11;
        DlgCreate("Query",75,5);
        DlgText("Use existing power in band channels?",2,1);      
        DlgButton(0,"No|Create new power in band channels",Cancelx%);
        DlgButton(1,"Yes||Hotkey <Enter>",OKx%);
        redoflg%:=DlgShow();
        redoflg%:=not redoflg%;                         ' reverse polarity
    endif;
else
    redoflg%:=1;                                        ' online
endif;

if redoflg%=1 then
    eegchlst%[0]+=4194304;                              ' short form channel name
    bw:=0.5;                                            ' when bin edges do not match the band edges, fractions of bins will be included
    drandx%:=12;
    DlgCreate("OSD setup",dxra[drandx%],dyra[drandx%]);
    DlgAllow(511,0,SetUpChnge%);
    DlgGroup("EMG processing",1,1,45,2);
    DlgReal(1,"RMS time constant (s)|Smoothed Root mean square emg",0.0,10.0,0,2,0.1);
    
    DlgGroup("EEG Power in bands",1,3.5,45,7.5);
    DlgGroup("",1,5,45,6);
    DlgText(" Band",6,5.8);
    DlgText("Low (Hz)",21,5.8);
    DlgText("High (Hz)",37,5.8);
    for i%:=0 to 3 do
        DlgText("to",32,6.8+i%);
    next;
    DlgText(" Delta",6,6.8);
    DlgText("Theta",6,7.8);
    DlgReal(2,8,0,50.0,22,6.8,bw);                      ' band edges
    DlgReal(3,8,0,50.0,37,6.8,bw);
    DlgReal(4,8,0,50.0,22,7.8,bw);
    DlgReal(5,8,0,50.0,37,7.8,bw);
    
    DlgReal(6,8,0,50.0,22,8.8,bw);
    DlgReal(7,8,0,50.0,22,9.8,bw);
    DlgReal(8,8,0,50.0,37,8.8,bw);
    DlgReal(9,8,0,50.0,37,9.8,bw);
    DlgCheck(10,"",2,8.8);
    DlgCheck(11,"",2,9.8);
    DlgString(12,12,9,"",7,8.8,"Band 1|");
    DlgString(13,12,9,"",7,9.8,"Band 2|");
    DlgReal(14,"Smoothing time constant (s)",0,10.0,0,4.3,0.1);    
    DlgButton(0,"Cancel",Cancelx%);
    DlgButton(1,"OK|0x0d|hotkey: <Enter>",OKx%);
    ok%:=DlgShow(rmstc,dedgelo,dedgehi,tedgelo,tedgehi,udedgelo[],udedgehi[],udbndchk%[],udbndttl$[],tc);
    
    if ok% then
        Yield();                                        ' allow time for dialog to close
        leeway:=Max(rmstc,tc);                          ' time to wait before taking measurements online (ie. until chan process has taken effect)
        emgeeg$:=Print$("%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,",onchk%[],eegch%[],emgch%[]);
        Profile(key$,"chansetc",emgeeg$);
        
        bnds$:=Print$("%.2f,%d,%.2f,%.2f,%.2f,%.2f,%d,%d,%.2f,%.2f,%.2f,%.2f,\"%s\",\"%s\",%.2f",
        rmstc,dummych%,tedgelo,tedgehi,dedgelo,dedgehi,udbndchk%[0],udbndchk%[1],udedgelo[0],udedgelo[1],udedgehi[0],udedgehi[1],udbndttl$[0],udbndttl$[1],tc);
        Profile(key$,"bandsetc",bnds$);                 ' save latest band selections for next time
        View(tvh%);                                     ' 
        ToolbarText("Generating Power in band channels. This may take a while...");
        YAxisMode(8192,1,9,0);                          ' horizontal y-axis labels 
        
        ChanHide(-1);
        for j%:=0 to nchk%-1 do
            ChanShow(emgch%[j%],eegch%[j%]);
            ChanOrder(eegch%[j%],1,emgch%[j%]);         ' emg below eeg (power channels order above eeg)
            vdeltach%[j%]:=DoBandChan%(eegch%[j%],dedgelo,dedgehi,stepsz,"Delta","uV^2",223.0,78.0,243.0,tc); ' pink
            vthetach%[j%]:=DoBandChan%(eegch%[j%],tedgelo,tedgehi,stepsz,"Theta","uV^2",92.0,133.0,228.0,tc); ' blue  trace using rgb values in <Custom Colours> palette
            
            deltach%[j%]:=NewChannel%(vdeltach%[j%],eegch%[j%]); ' disk-based copies
            thetach%[j%]:=NewChannel%(vthetach%[j%],eegch%[j%]); ' real versions of the banded power channels (data added by idle routine)
            vtdch%[j%]:=VTDratioChan%(vthetach%[j%],vdeltach%[j%],Print$("T:D (%d)",eegch%[j%]),"",250.0,112.0,20.0); ' Virtual Power ratio based on smoothed disk-based theta and delta power 
            tdch%[j%]:=NewChannel%(vtdch%[j%],eegch%[j%]);
            for i%:=0 to 1 do
                if udbndchk%[i%] then                   ' optional user-defined band channels
                    vudbndch%[i%][j%]:= DoBandChan%(eegch%[j%],udedgelo[i%],udedgehi[i%],stepsz,udbndttl$[i%],"uV^2",udr[i%],udg[i%],udb[i%],tc);
                    udbndch%[i%][j%]:=NewChannel%(vudbndch%[i%][j%],eegch%[j%]);
                    YAxisStyle(udbndch%[i%][j%],0,0);
                    YAxisAttrib(udbndch%[i%][j%],4);
                endif;
            next;
            
            YAxisStyle(Print$("%d,%d,%d,%d",deltach%[j%],thetach%[j%],tdch%[j%]), 0, 0); ' auto units x1000s         ,udbndch%[i%][j%]
            YAxisAttrib(Print$("%d,%d,%d,5d",deltach%[j%],thetach%[j%],tdch%[j%]), 4); ' ,udbndch%[i%][j%]
            
            if onofflineflg%=0 and rrchk%=0 then        ' offline: copy virtual channels to permanent channels  in blocks
                ChanSaveAppend%(vdeltach%[j%],deltach%[j%],eegch%[j%],600);            
                ChanSaveAppend%(vthetach%[j%],thetach%[j%],eegch%[j%],600);                
                ChanSaveAppend%(vtdch%[j%],tdch%[j%],eegch%[j%],600);
                for i%:=0 to 1 do
                    if udbndchk%[i%] then               ' append recent data to disk-based user-defined band channels
                        ChanSaveAppend%(vudbndch%[i%][j%],udbndch%[i%][j%],eegch%[j%],600);
                    endif;
                next;
                
                ChanDelete(Print$("%d,%d,%d",vthetach%[j%],vdeltach%[j%],vtdch%[j%])); ' delete virtual channels -we now have disk-based copies
                for i%:=0 to 1 do
                    if udbndchk%[i%] then
                        ChanDelete(vudbndch%[i%][j%]);  ' delete user-defined channel(s)
                    endif;      
                next;
            endif;       
        next;
        if onofflineflg%=0 and rrchk%=0 then
            Newsflash("Finished plotting power in bands.",0,70,10,1); ' not re-run or online
        else
            ToolbarText("");
        endif;
    endif;
endif;

'=====
if ok% or redoflg%=0 then                               ' set up buttons for next stage of Analysis
    var btn%[10]:={1,17,18,8,9,10,11,12,28,29};
    ToolbarEnable(all%,off%);
    ToolbarEnable(btn%[:3],on%);
    ToolbarEnable(btn%[8:2],on%);    
    if nchk%>1 then ToolbarEnable(btn%[7],on%); endif;  ' enable Show button if there is a choice
    if onofflineflg%=1 and rrflg%=1 then ToolbarEnable(14,on%); endif; ' enable start button for online or rerun.
    for i%:=0 to nchk%-1 do
        ToolbarEnable(btn%[i%+3],on%);
    next;    
else
    var bt%[8]:={1,2,3,4,17,18,28,29};                  ' user Cancelled the dialog
    ToolbarEnable(all%,off%);
    ToolbarEnable(bt%[],on%);
endif;
return 1;
end;

func ChanSaveAppend%(srcch%,destch%,eegch%,tblock);
'save source chan to pre-existing destination channel in  blocks (default: 600s)
'so that user can see progress
var t1:=-tblock,t2:=0.0,ok%;                            ' minV,maxV,
var nblk%,cnt%,progress,ttt;

YRange(destch%,0.0,YHigh(srcch%));
ttt:=MaxTime(eegch%);
nblk%:=ttt/tblock;
repeat
    t1+=tblock; t2+=tblock;
    t2:= Min(t2,View(tvh%).MaxTime(eegch%));
    ok%:=ChanSave(srcch%,destch%,0,t1,t2);              ' save banded power to permanent channels (1 FFT block behind)
    Yield();                                            ' give time to draw it
    cnt%+=1;
    progress:=100.0*cnt%/nblk%;
    ToolbarText(Print$("Plotting  %s.    Progress:  %.0f %%",ChanTitle$(destch%),progress));
until t2>= ttt;                                         ' srcch%   stop at end of raw data
ToolbarText("");
return 1;
end;

func NewChannel%(srcch%,destch%)                        ' create a new RealWave channel using ChanNew() based on specified source channel
var newch%,r,g,b;

newch%:=ChanNew(0,9,0,BinSize(srcch%));
ChanTitle$(newch%,ChanTitle$(srcch%));
ChanUnits$(newch%,ChanUnits$(srcch%));
ChanComment$(newch%,ChanComment$(srcch%));
ChanColourGet(srcch%,1,r,g,b);
ChanColourSet(newch%,1,r,g,b);
YRange(newch%,0.0,YHigh(srcch%));
ChanShow(newch%);
ChanOrder(destch%,-1,newch%);                           ' group above destch% channel
ChanSelect(newch%,1);
return newch%;
end;

func DoBandChan%(eegch%,edgelo,edgehi,stepsz,ttl$,units$,r,g,b,tc) ' create virtual power in band channels
'current view must be the time view
var expr$,vpch%;

if onofflineflg%=0 and rrchk%=0 then
    ToolbarText(Print$("Calculating:  %s (%d)",ttl$,eegch%)); ' message not appropriate for online or rerun
endif;
vpch%:=VirtualChan(0,"");
expr$:=Print$("Pw(%d,%.4f,%.4f,%.4f)",eegch%,stepsz,edgelo,edgehi); ' power in band
ttl$:=Print$("%s(%d)",ttl$,eegch%);
ChanComment$(vpch%,Print$("Power in band: %.1f - %.1f Hz;  tc: %.1fs",edgelo,edgehi,tc));
VirtualChan(vpch%,expr$,0,0.1,0.0);
ChanColourSet(vpch%,1,r/256,g/256,b/256);	 
ChanTitle$(vpch%,ttl$);
ChanUnits$(vpch%,units$);
if tc>0 then
    ChanProcessAdd(vpch%,1,tc);
endif;
if onofflineflg%=0 then
    Optimise(vpch%,0.1*MaxTime(),0.9*MaxTime());        ' exclude start and end (more likely to be artifacts?)
endif;
return vpch%;
end;

func VTDratioChan%(ach%,bch%,ttl$,units$,r,g,b)
var vch%,expr$;

if onofflineflg%=0 and rrchk%=0 then
    View(tvh%);ToolbarText("Calculating:  T:D ratio."); ' message not appropriate for online or rerun
endif;
vch%:=VirtualChan(0,"");
expr$:=Print$("ch(%d)/ch(%d)",ach%,bch%);
ChanComment$(vch%,Print$("%s / %s",ChanTitle$(ach%),ChanTitle$(bch%)));
VirtualChan(vch%,expr$,0,BinSize(ach%),0.0);
ChanColourSet(vch%,1,r/256,g/256,b/256);	 
ChanTitle$(vch%,ttl$);
ChanComment$(vch%,"T:D ratio");
if onofflineflg%=0 then
    Optimise(vch%,0.1*MaxTime(),0.9*MaxTime());         ' exclude start and end (more likely to be artifacts?)
endif;
return vch%;
end;

func DoSStart%()
ttableflg%:=0;                                          ' override schedule
SStart%();
return 1;
end;

func SStart%()
var ok%,try%,i%,yofs,yh:=100;

stimflag%:=0; twdone%:=0;                               ' itialise time window variables

ArrConst(nseq%[],0);                                    ' reset stim sequence counter
View(tvh%);
for i%:=0 to nchk%-1 do
    if ChanKind(sstatech%[i%])<>8 then                  ' You must set up Stage Definitions for all animals before sampling
        NewsFlash(Print$("Please Set up the Stage definitions for animal <#%d> before sampling.",i%+1),4,0,5,0);
        return 1;
    endif;
next;
for i%:=0 to nchk%-1 do
    dupssch%[i%]:=ChanDuplicate(sstatech%[i%]);         ' hidden duplicate states channel with terminators hidden (used for pulse o/p)
    MarkMask(dupssch%[i%], 0);                          ' set mode 0
    MarkMask(dupssch%[i%],-1, 1,-1);                    ' include everything (reset)
    MarkMask(dupssch%[i%], 0, 0, 0,9,255);              ' exclude codes 0 and 9 layer 0   (undefined  and terminators)
next;

docase
case onofflineflg%=1 then                               ' processing online
    FrontView(tvh%);
    SampleWrite(1);
    SampleStart();
    
    var tplsticks%,ipiticks%;                           ' convert dialog time values to sequencer clock ticks   ,ititicks%
    var ticksperms%:=10.0;    
    tplsticks%:=(tpls*ticksperms%)-1;                   ' pulse duration (allow 1 tick for Delay instructions)
    ipiticks%:=(ipi*ticksperms%)-1;                     ' inter-pulse interval
    
    SampleSeqVar(1,tplsticks%);                         ' pass o/p pulse pattern to the sequencer
    SampleSeqVar(2,ipiticks%);
    SampleSeqVar(3,np%);
    Seconds(0);
    
case rrchk%=1 then                                      ' re-run =simulated online
    View(tvh%);
    repeat
        ok%:=PlayOffline(emgch%[0],rrdac%,st,MaxTime(),1,rspeed,1+2); ' Start re-run with soundcard
        if ok%<0 then rrdac%:=0; endif;                 ' if that fails try dac0
        try%+=1;
    until ok%=0 or try%>=2;                             ' else admit defeat
    
    if try%>=2 and ok%<0 then
        Message("Error|PlayOffline() error:   %d\nIs the 1401 connected and switched on ?",ok%);
        return 1;
    endif;
    XRange(st);
    Yield();
    XRange(-1);                                         ' scroll
    rrflg%:=1;                                          ' switch on idle processing   
endcase;

if nchk% <=3 then yofs:=33.3; else yofs:=25; endif;
if pscheck% then                                        ' power spectrum option enabled
    for i%:=0 to nchk%-1 do
        pvh%[i%]:=SetPower(eegch%[i%],512,1);           ' Hanning window
        Window(75,yh-yofs,97,yh);                       ' top right corner
        WindowTitle$("Spectrum  #"+Str$(i%+1));
        XRange(0,30);                                   ' Hz
        WindowVisible(1);
        ProcessAuto(sdur,1,1,sdur,0.5);                 ' process at one epoch intervals (not necessarily at epoch boundaries)
        yh-=yofs; 
    next;    
endif;

View(tvh%);
ToolbarClear(samplebtn%);
ToolbarSet(samplebtn%,"&Stop||Hotkey: S;  Stop sampling",SStop%);
if rrchk%=0 then
    ToolbarEnable(sabortbtn%,on%);                      ' enable abort if sampling but not if re-running
endif;

FileTimeDate(ftd%[]);                                   ' convert to seconds since year start
'        s       m          hr           days
sss%:=ftd%[0]+ftd%[1]*60+ftd%[2]*3600+(ftd%[3]-1)*24*3600; ' seconds since beginning of month
if ftd%[4]>1 then                                       ' add in seconds from previous months
    var tt%;
    tt%:=ArrSum(sperm%[:ftd%[4]-1]);
    if ftd%[4] mod 4 =0 then tt%+=3600*24; endif;       ' add in extra day for leap year
    sss%+=tt%;                                          ' start time in sec since start of year
endif;
ArrConst(trfr[],0);                                     ' reset end time of refrractoriness array
return 1;
end;

func SAbort%()
var i%;

SampleKey("z");
Yield();
SampleAbort();

for i%:=0 to nchk%-1 do
    if ViewKind(pvh%[i%])=4 then                        ' close power spectrum if there is one.
        View(pvh%[i%]);
        FileClose(0,-1);
    endif;
next;

ToolbarText("");
ToolbarClear(samplebtn%);
ToolbarSet(samplebtn%,"&Start||Hotkey: S;  Start sampling",SStart%);

var btn%[6]:={1,2,3,4,28,29};                           ' quit,new,old,rr
ToolbarEnable(all%,off%);
ToolbarEnable(btn%[],on%);
return 1;
end;

func StageDef1%()
anr%:=1;
StageDefine%();
return 1;
end;

func StageDef2%()
anr%:=2;
StageDefine%();
return 1;
end;

func StageDef3%()
anr%:=3;
StageDefine%();
return 1;
end;

func StageDef4%()
anr%:=4;
StageDefine%();
return 1;
end;

func StageDefine%()                                     ' set up to 3 sets of criteria for marking wake, NREM and REM Sleep
'based on rms emg level and power in a selected band.
var i%,yp;
var ok%;
var lst%[10],alst%[10],astr$;
var olst%[50];                                          ' list of channels to optimise

if ttableflg%  then
    ' ToolbarText(Print$("  Start recording :  %s (%s);  Start stimulation :  %s (%s);  End stimulation :  %s %s",sttime0$,stdate0$,sttime$,stdate$,sttime2$,stdate2$)); ' scheduling message
    ToolbarText(Print$("  Start / End recording :  %s (%s) / %s (%s);   Start / End stimulation :  %s (%s) / %s  %s",
    sttime0$,stdate0$,sttime1$,stdate1$,sttime$,stdate$,sttime2$,stdate2$));
endif;

if ViewKind(tvh%)<>0 then 
    Newsflash("Time view not found.",30,75,5,0);
    return 1;
endif;

View(tvh%);
HCursorDelete(-1);
lst%[0]:=4194304+1;                                     ' short format labels
lst%[1]:=emgch%[anr%-1];                                ' show only emg channel from selected animal

' build a list of possible power channels for this animal
pwrlst%[0]:=4194304;                                    ' short-form channel titles in dialog
pwrlst%[1]:=deltach%[anr%-1];     pwrlst%[0]+=1;        ' delta 
pwrlst%[2]:=thetach%[anr%-1];     pwrlst%[0]+=1;        ' theta
pwrlst%[3]:=tdch%[anr%-1];     pwrlst%[0]+=1;           ' theta : delta
if udbndchk%[0] then
    pwrlst%[4]:=udbndch%[0][anr%-1]; pwrlst%[0]+=1;
endif;
if udbndchk%[1] then
    pwrlst%[5]:=udbndch%[1][anr%-1]; pwrlst%[0]+=1;
endif;
var lb$;
for i%:=0 to 3 do
    lb$:= Print$("=%s\\[%d\\]",sslbl$[i%],eegch%[anr%-1]);
    ChanList(alst%[],lb$,512);                          ' use existing virtual channels if possible
    if alst%[0]>0 then
        ssch%[i%][anr%-1]:=alst%[1];
        YRange(ssch%[i%][anr%-1],0,1.1);
        ChanShow(ssch%[i%][anr%-1]);                    ' show pre-existing sleep stage marker channels
    else
        ssch%[i%][anr%-1]:=0; endif;
next;

if sdhidechk% then                                      ' option to hide data from other animals in Preferences (15/07/2016)
    ChanHide(-1);
endif;

ChanShow(lst%[],pwrlst%[],Print$("%d,%d",eegch%[anr%-1],emgch%[anr%-1])); ' show channels related to the chosen animal
ChanShow(opch%[anr%-1],sstatech%[anr%-1]);              ' show relevant output and sleep stage channels
ChanList(olst%[],1+512+2048);                           ' visible waveforms and realwaves
if sdoptchk% then
    Optimise(olst%[]);                                  ' option to optimise in Preferences (15/07/2016)
endif;
var t$:=Print$("Sleep Stage Definitions ANIMAL #%d",anr%);
dlgopenflg%:=1;                                         ' flag top main idle that stage define is open
drandx%:=13;
DlgCreate(t$,dxra[drandx%],dyra[drandx%],111,15);
DlgAllow(511,SSDefidl%,SSDefChnge%);
yp:=2;
for i%:=0 to 2 do
    DlgGroup(sslbl$[i%],1,yp-1,51,4);
    DlgText("EMG",6,yp);
    DlgText(" +",2,yp+0.9);
    DlgText("Pwr",6,yp+1);
    DlgText("Options:",2,yp+2);
    DlgButton(2+i%,"Fetch H-Csrs",HCFetch%,37,yp+2);
    DlgButton(5+i%,"Suggest||a reasonable starting point -we hope!",SuggestSettings%,11,yp+2);
    yp+=4.5;
next;
yp:=1.8;
for i%:=1 to 3 do
    DlgCheck(i%,"",2,yp);                               ' Enable sleep state channels
    yp+=4.5;
next;

yp:=2;
for i%:=4 to 6 do
    DlgChan(i%,15,lst%[],12,yp);                        ' emg channels
    yp+=4.5;
next;
yp:=2;
for i%:=7 to 9 do
    DlgList(i%,6,op$[],3,30,yp);                        ' emg operators
    yp+=4.5;
next;
yp:=2;
for i%:=10 to 12 do
    DlgReal(i%,12,-1.0e9,1.0e9,39,yp,1);                ' emg thresholds
    yp+=4.5;
next;
yp:=3;
for i%:=13 to 15 do
    DlgList(i%,15,"Delta|Theta|T:D",3,12,yp);           ' power band selector
    yp+=4.5;
next;
yp:=3;
for i%:=16 to 18 do
    DlgList(i%,6,op$[],3,30,yp);                        ' pwr operators
    yp+=4.5;
next;
yp:=3;
for i%:=19 to 21 do
    DlgReal(i%,12,0.0,1.0e9,39,yp,0.1);                 ' pwr threshold
    yp+=4.5;
next;

DlgGroup(Print$("Pulse output (Digital o/p %d)",anr%-1),55,6.5,54,5);
DlgText("Enable",59,7.5);
DlgCheck(22,"",56,7.5);
di%[0]:=DlgText("TIMETABLE :",56,10.5);
di%[1]:=DlgText(Print$("Outputs enable time :  %s     %s",sttime$,stdate$),70,10.5);
di%[2]:=DlgText("h : m : s ",89,9.8);

DlgText("Stage detected",81,7.5);
DlgList(23,8,"WAKE|NREM|REM",3,-3,7.4);
DlgText("Refractory period (s)|Minimum delay before next pulse.",81,8.5);
DlgReal(24,8,0,3000.0,-3,8.4,sdur);

DlgGroup("TIP",55,12,54,2);
DlgText("Drag horizontal cursors to change threshold levels",62,13);

DlgGroup("DOUBT and AMBIGUITY",55,1,54,5);                            ' afterthought
DlgText("Code as DOUBT epochs",56,1.9);
DlgString(27,8,3,"",-3,1.9);
DlgText("if unclassified portion of an epoch exceeds...(%)",56,2.9);
DlgReal(25,8,5,80.0,-3,2.9,1);

DlgText("Code as AMBIGUOUS epochs",56,4.1);
DlgString(28,8,3,"",-3,4.1);
DlgText("if ambiguous portion of an epoch exceeds...(%)",56,5.1);
DlgReal(26,8,1,80.0,-3,5.1,1);
if rrchk%=1 or SampleStatus()>=0 then                   ' No <Cancel> button if online or re-run selected
    DlgButton(0,"");
endif;
DlgButton(0,"Cancel",Cancelx%);
DlgButton(1,"OK",OKx%);
ok%:=DlgShow(sschk%[][anr%-1],ssdefch1%[][anr%-1],ssopndx1%[][anr%-1],sslvl1[][anr%-1],pchndx%[][anr%-1],ssopndx2%[][anr%-1],sslvl2[][anr%-1],opchk%[anr%-1],ssndx%[anr%-1],trefract[anr%-1],pcscored,pcambig,ss$[0],ss$[4]); ' ssdefch2%[][anr%-1]
dlgopenflg%:=0;
Yield();                                                ' give time for the dialog to close

if ok%=0 then                                           ' <Cancel> only available off-line
    ChanDelete(ssch%[3][anr%-1]);                       ' delete ambig mkr
    ChanList(lst%[],"=Pred",4+2048+4096);               ' visible predicted o/p chans in mem buffers
    ChanDelete(lst%[]);
    
    astr$:= Print$("%d,%d,%d,%d,%d",thetach%[anr%-1],deltach%[anr%-1],tdch%[anr%-1],udbndch%[0][anr%-1],udbndch%[1][anr%-1]);
    ChanList(lst%[],astr$,512);                         ' list of newly created realwave channels
    for i%:=1 to lst%[0] do
        if MaxTime(lst%[i%])<0 then                     ' delete them if they are empty
            ChanDelete(lst%[i%]);
        endif;
    next;
    
    astr$:= Print$("%d,%d,%d,%d",ssch%[0][anr%-1],ssch%[1][anr%-1],ssch%[2][anr%-1],ssch%[3][anr%-1]);
    ArrConst(ssch%[][anr%-1],0);                        ' reset chan numbers (so Show buttons knows they no longer exist)
    ChanList(lst%[],astr$,512);                         ' list of newly created Virtual stage markers channels
    for i%:=1 to lst%[0] do
        ChanDelete(lst%[i%]);
    next;
    if nchk%>1 then
        ToolbarEnable(showbtn%,on%);                    ' avoid crashes when trying to show /hide non-existent channel
    else
        ToolbarEnable(showbtn%,off%);
    endif;    
else                                                    ' OK or cancelled while sampling or re-running means continue with latest settings
    thr:=1.0-(pcscored*0.01);                           ' score as doubt if W+N+R , threshold
    thr2:=pcambig*0.01;                                 ' convert % conflict to 0-1
    ss%[anr%-1]:=ssndx%[anr%-1]+1;                      ' derive state code from state index%
    
    var chlst%[2],aname$;
    aname$:= Print$("=[Ss]tage\\(%d\\)",anr%);   
    ChanList(chlst%[],aname$,32+4096+16384);            ' check for memory buffer <Stage> marker 
    if chlst%[0]>0 then
        sstatech%[anr%-1]:=chlst%[1];                   ' if stages buffer exists use it
    else
        ChanList(chlst%[],Print$("=[Ss]tage\\(%d\\)",anr%),32+2048+8192+16384); ' look for a visible disk-based Stage channel (keep hidden ones!)    
        if chlst%[0]=1 then
            ChanDelete(chlst%[1]);                      ' delete old one
            ChanList(chlst%[],"=VM",32);
            if chlst%[0]=1 then ChanDelete(chlst%[1]); endif; ' delete vertical marker channel if necessary
        endif;
        
        if SampleStatus()<>2 and rrchk% =0 then
            if ChanKind(sstatech%[anr%-1])=8 then ChanDelete(sstatech%[anr%-1]); sstatech%[anr%-1]:=0; endif;
            ' if working offline (not sampling and not rerunning) then delete existing stage marker. We will make a new one with new settings
        endif;        
        
        sstatech%[anr%-1]:=StageMkrChan%();             ' create new stages buffer
    endif;
    ' ==========
    ChanList(chlst%[],Print$("=Pred \\(%d\\)",anr%),4+4096+16384); ' check for predicted pulse channel
    if  opchk%[anr%-1] then                             ' if pulse o/p selected
        if chlst%[0]>0 then                             ' if we find one
            opch%[anr%-1]:=chlst%[1];
            if onofflineflg%=0 and rrchk%=0 then 
                MemDeleteTime(opch%[anr%-1],3,0,MaxTime()); ' clear existing ready for re-use if offline and not rerunning
            endif;
        else
            opch%[anr%-1]:=OPPredChan%(anr%);           ' create new predicted pulse buffer
        endif;
    else
        if chlst%[0]>0 then                             ' predicted pulse channel exists but no longer selected
            ChanDelete(chlst%[1]);                      ' get rid
        endif;
    endif;
    ' ==========
    var pulsesch%,endt;
    docase
    case onofflineflg%=0 and rrchk%=0 then              ' offline analysis
        StageMkrOffline%(ssch%[][anr%-1],sdur);
        if opchk%[anr%-1] then
            pulsesch%:=PulsePattern%(st,endt);
            PulseOutOffline%(anr%-1,pulsesch%,st,endt);
            ChanDelete(pulsesch%);
        endif;
    case onofflineflg%=1 then                           ' online processing
        ToolbarEnable(samplebtn%,on%);
        ToolbarEnable(sabortbtn%,on%);        
        ChanList(lst%[],Print$("=op %d",anr%),4);
        opch%[anr%-1]:=lst%[1];
        ChanShow(opch%[anr%-1]);
        if ChanKind(opch%[anr%-1])<>4 then
            Newsflash(Print$("%s channel not found in sampling configuration.",Print$("op %d",anr%)),3,0,0,1);
            opchk%[anr%-1]:=0;
        else
            ChanShow(opch%[anr%-1]);                                                   
            ChanSelect(opch%[anr%-1],1);      
        endif;
    case rrchk% then        
        ToolbarEnable(samplebtn%,on%); 
    endcase;
    showflg%:=0; showopt%:=0;
    ShowBtns%();                                        ' revert to showing results from all animals
    ToolbarEnable(vmbtn%,on%);
    ToolbarEnable(editbtn%,on%);
    ToolbarEnable(tablebtn%,on%);
    ToolbarEnable(gpwrbtn%,on%);
    '    docase   'gated power analysis is off-line only
    '    case PlayOffline(0)=-1 then ToolbarEnable(gpwrbtn%,on%);
    '    case SampleStatus()=-1 then ToolbarEnable(gpwrbtn%,on%);
    '    else ToolbarEnable(gpwrbtn%,off%);    
    '    endcase;
    ToolbarEnable(showbtn%,on%);
endif;
if ChanKind(vmch%)=8 then ChanShow(vmch%); endif;       ' show stim on stste channel if present
return 1;
end;

func ShowDlgChnge%(item%)
var i%,b%;

if item%=0 then
    DlgEnable(0,-2,-3,-4,-5);
    for i%:=1 to nchk% do                               ' disable buttons if no data for that animal
        b%:=-(i%+1);
        DlgEnable(1,b%);        
    next;   
endif;
return 1;
end;

func Show%()
var i%,itm%:=2;
var xp:=3,yp:=1;

var pr$[5]:={"Animal #1","Animal #2","Animal #3","Animal #4","  -- All --  "};
View(tvh%);
showflg%:=1;
drandx%:=14;

DlgCreate("Display",dxra[drandx%],dyra[drandx%]);
DlgAllow(511,idle%,ShowDlgChnge%);
for i%:=1 to 5 do
    DlgButton(itm%,pr$[i%-1],ShowBtns%,xp,yp);
    xp+=12;
    if i%=4 then yp+=1; xp:=15; endif;
    itm%+=1;    
next;
'xp+=1;
DlgButton(0,"");                                        ' No <Cancel> button
DlgButton(1,"-- Close --",OKx%,xp,yp);
DlgShow();
showflg%:=0;
return 1;
end;

func ShowBtns%()
var j%,i%,vis%;

ChanHide(-1);
if (showflg% and DlgButton()=6) or (showflg%=0 and showopt%=0) then ' Show All
    shw%:=0;                                            ' Flag tbtxt data for animal 1 only
    HCursorDelete(-1)                                   ' can't show thresholds for more than one animal
    for j%:=0 to nchk%-1 do
        if rrchk% and rawchk%=0 then
            ChanHide(Print$("%d,%d",eegch%[j%],emgch%[j%]));
        else
            ChanShow(Print$("%d,%d",eegch%[j%],emgch%[j%]));
        endif;
        ChanShow(Print$("%d,%d,%d,%d,%d,%d",sstatech%[j%],thetach%[j%],deltach%[j%],tdch%[j%],udbndch%[0][j%],udbndch%[1][j%])); ' stage and spectral channels
        ChanShow(ssch%[0][j%],ssch%[1][j%],ssch%[2][j%],ssch%[3][j%]); ' stage markers
        ChanShow(opch%[j%]); ChanSelect(opch%[j%],1);   ' show and select output channels
        ChanSelect(sstatech%[j%],1); ChanSelect(thetach%[j%],1); ChanSelect(deltach%[j%],1); ChanSelect(tdch%[j%],1);
        ChanSelect(ssch%[0][j%],1); ChanSelect(ssch%[1][j%],1); ChanSelect(ssch%[2][j%],1);  Chanselect(ssch%[3][j%],1);
        ChanSelect(udbndch%[0][j%],1); Chanselect(udbndch%[1][j%],1);
        
        if ViewKind(pvh%[j%])=4 then
            View(pvh%[j%]).WindowVisible(1);            ' show power spectra if present
        endif;
    next;
    
    ' order channels
    var lst%[10];
    for j%:=0 to nchk%-1 do                             ' process each set of power spectral channels in turn
        if ArrSum(ssch%[][j%]) >0 then                  ' if markers for individal sleep stages were created then create a <Stage channel>
            ArrConst(lst%[1:],ssch%[][j%]);
            lst%[0]:=6;
            lst%[5]:=sstatech%[j%];
            lst%[6]:=opch%[j%];
            if ChanKind(deltach%[j%]) = 9 then
                for i%:=lst%[0] to 1 step -1 do
                    if ChanKind(lst%[i%])>0 then        ' cope with missing channels
                        ChanOrder(deltach%[j%],-1,lst%[i%]); ' order channels above delta power -if it exists.
                    endif;
                next;
            endif;
        endif;    
    next;
else    
    j%:=DlgButton()-2;
    if j%<0 then j%:=showopt%-1; endif;                 ' use show option to choose data to show after Stage Define%()
    shw%:=j%;                                           ' tbtxt data for currently displayed animal
    if rrchk% and rawchk%=0 then
        ChanHide(Print$("%d,%d",eegch%[j%],emgch%[j%]));
    else
        ChanShow(Print$("%d,%d",eegch%[j%],emgch%[j%]));
    endif;
    var x$;
    x$:=Print$(Print$("%d,%d,%d,%d,%d,%d",thetach%[j%],deltach%[j%],tdch%[j%],sstatech%[j%],udbndch%[0][j%],udbndch%[1][j%]));
    ChanShow(x$);                                       ' stage and spectral channels
    ChanShow(ssch%[0][j%],ssch%[1][j%],ssch%[2][j%],ssch%[3][j%]); ' stage markers
    ChanSelect(sstatech%[j%],1); ChanSelect(thetach%[j%],1); ChanSelect(deltach%[j%],1); ChanSelect(tdch%[j%],1);
    ChanSelect(ssch%[0][j%],1); ChanSelect(ssch%[1][j%],1); ChanSelect(ssch%[2][j%],1);  ChanSelect(ssch%[3][j%],1);
    ChanSelect(udbndch%[0][j%],1); ChanSelect(udbndch%[1][j%],1);
    ChanShow(opch%[j%]); ChanSelect(opch%[j%],1);       ' show and select output channels
    
    var nn%:=5;
    if ArrSum(ssch%[][j%]) >0 then                     
        ArrConst(lst%[1:],ssch%[][j%]);
        lst%[0]:=4;
        if ChanKind(sstatech%[j%])=8 then               ' include state channel if present
            lst%[nn%]:=sstatech%[j%];
            nn%+=1;
            lst%[0]+=1;
        endif;
        if ChanKind(opch%[j%])=4 then                   ' include output channel if present
            lst%[nn%]:=opch%[j%];
            nn%+=1;
            lst%[0]+=1;
        endif;
        
        if ChanKind(deltach%[j%]) = 9 then
            ChanOrder(deltach%[j%],-1,lst%[]);          ' order channels above delta power -if it exists.
        endif;
    endif;
    for i%:=0 to nchk%-1 do    
        if ViewKind(pvh%[i%])=4 then
            if i%=j% then vis%:=1; else vis%:=0; endif;
            View(pvh%[i%]).WindowVisible(vis%);         ' show current power spectrum if present hide any others
        endif;
    next;
endif;
if sdoptchk% then
    Optimise(-1);
endif;
return 1;
end;

func OPPredChan%(n%)
var opch%;

View(tvh%);
opch%:=MemChan(4);
ChanTitle$(opch%,Print$("Pred (%d)",n%));
ChanShow(opch%);
ChanSelect(opch%,1);
CursorSet(1);
return opch%;
end;

func HCFetch%()
var btn%,pos,ch%,hcn%;    

btn%:=DlgButton();
ch%:= DlgValue(btn%+2);                                 ' emg channel
pos:=YLow(ch%)+(YHigh(ch%)-YLow(ch%))*0.5;              ' middle of visible range
docase
case btn%=2 then hcn%:=hc%[1];
case btn%=3 then hcn%:=hc%[3];            
case btn%=4 then hcn%:=hc%[5];
endcase;
HCursor(hcn%,pos,ch%);                                  ' re-position cursor in emg channel
ch%:=pwrlst%[DlgValue(btn%+11)+1];                      ' selected spectral channel
pos:=YLow(ch%)+(YHigh(ch%)-YLow(ch%))*0.5;              ' middle of visible range
docase
case btn%=2 then hcn%:=hc%[2];
case btn%=3 then hcn%:=hc%[4];            
case btn%=4 then hcn%:=hc%[6];
endcase;
HCursor(hcn%,pos,ch%);                                  ' re-position cursor in spectral channel
return 1;
end;

func SuggestSettings%()                                 ' restore factory /previous settings for stage detection
var btn%;
var chlst%[2],emgch%,emgthr,powthr,sdemg,sdpwr;
'var nproc%;

btn%:=DlgButton();

View(tvh%);
docase
case btn%=5 then                                        ' suggest WAKE settings   
    emgch%:=DlgValue(4);
    DlgValue(7,0);                                      ' emg>=
    emgthr:=ChanMeasure(emgch%,2,0,MaxTime());          ' mean emg activity in file
    sdemg:=ChanMeasure(emgch%,12,0,MaxTime());
    emgthr:=emgthr-0.6*sdemg;
    emgthr:=Trunc(emgthr*100)/100.0;   
    DlgValue(10,emgthr);                                ' emg threshold  for WAKE  
    
    ChanList(chlst%[],"=[Tt]:[Dd]",512+2048);
    DlgValue(13,2);                                     ' set T:D ratio  chlst%[1]
    DlgValue(16,0);                                     ' pwr >=
    
    ChanProcessAdd(chlst%[1],11);                      'remove non-numbers
    ChanProcessAdd(chlst%[1],10,0,0.0);                           'Fillgaps process (so that chan measure works despite gaps at start and end)
    powthr:=ChanMeasure(chlst%[1],2,0,MaxTime());     ' mean T:D
    sdpwr:=ChanMeasure(chlst%[1],12,0,MaxTime());
    'ChanProcessInfo(chlst%[1]);
    ChanProcessClear(chlst%[1],-1);   'remove processes 
    powthr:=powthr-0.4*sdpwr;
    powthr:=Trunc(100*powthr)/100.0;                    ' 2 decimal places
    DlgValue(19,powthr);
    LinkDlgToHcsr(0,10,hc%[1],DlgValue(4),tvh%);        ' update horizontal cursor positions
    LinkDlgToHcsr(0,19,hc%[2],chlst%[1],tvh%);
    
case btn%=6 then                                        ' suggest NREM settings
    emgch%:=DlgValue(5);
    DlgValue(8,1);                                      ' emg<=
    emgthr:=ChanMeasure(emgch%,2,0,MaxTime());          ' mean emg activiry in file
    sdemg:=ChanMeasure(emgch%,12,0,MaxTime());
    emgthr:=emgthr-0.6*sdemg;
    emgthr:=Trunc(emgthr*100)/100.0;
    DlgValue(11,emgthr);                                ' emg threshold  for NREM
    
    ChanList(chlst%[],"=[Dd][Ee][Ll][Tt][Aa]",512+2048);    
    DlgValue(14,0);   
    DlgValue(17,0);                                     ' pwr >=
    
    powthr:=ChanMeasure(chlst%[1],2,0,MaxTime());     ' mean delta 
    sdpwr:=ChanMeasure(chlst%[1],12,0,MaxTime());
    powthr:=powthr-0.2*sdpwr;
    powthr:=Trunc(100*powthr)/100.0;                    ' 2 decimal places  
    DlgValue(20,powthr);
    LinkDlgToHcsr(0,11,hc%[3],DlgValue(5),tvh%);        ' update horizontal cursor positions
    LinkDlgToHcsr(0,20,hc%[4],chlst%[1],tvh%);
    
case btn%=7 then                                        ' suggest REM settings
    emgch%:=DlgValue(6);
    DlgValue(9,1);                                      ' emg<=
    emgthr:=ChanMeasure(emgch%,2,0,MaxTime());          ' mean emg activiry in file
    sdemg:=ChanMeasure(emgch%,12,0,MaxTime());
    emgthr:=emgthr-0.6*sdemg;
    emgthr:=Trunc(emgthr*100)/100.0;   
    DlgValue(12,emgthr);                                ' emg threshold  for WAKE
    
    ChanList(chlst%[],"=[Tt]:[Dd]",512+2048);    
    DlgValue(15,2);   
    DlgValue(18,0);                                     ' pwr >=
    ChanProcessAdd(chlst%[1],11);                      'remove non-numbers
    ChanProcessAdd(chlst%[1],10,0.1,0.0);                           'fill gaps
    powthr:=ChanMeasure(chlst%[1],2,0,MaxTime());     ' mean T:D
    sdpwr:=ChanMeasure(chlst%[1],12,0,MaxTime());
    'nproc%:=ChanProcessInfo(chlst%[1]);
    ChanProcessClear(chlst%[1],-1);   'remove processes
    powthr:=powthr-0.4*sdpwr;
    powthr:=Trunc(100*powthr)/100.0;                    ' 2 decimal places
    DlgValue(21,powthr);
    LinkDlgToHcsr(0,12,hc%[5],DlgValue(6),tvh%);        ' update horizontal cursor positions
    LinkDlgToHcsr(0,21,hc%[6],chlst%[1],tvh%);   
endcase;
stagedefineflg%:=1; 'give option to save new settings on <Quit>
return 1;
end;

func StageMkrChan%()
var ch%,code%[4];

View(tvh%);
ch%:=MemChan(8,10);
ChanTitle$(ch%,Print$("Stage(%d)",anr%));
ChanComment$(ch%,Print$("%.1f s epochs",sdur));         ' save epoch duration in comment
DrawMode(ch%,15,2);                                     ' states mode and text label
MemSetItem(ch%,0,XLow()+BinSize(),code%[]);             ' initial stage marker
lasttm:=XLow();                                         ' start time for first epoch on sleep state channel (sampling or rerun)
ChanShow(ch%);
ChanSelect(ch%,1);
ChanOrder(0,-1,ch%);                                    ' at the top
ChanSelect(ch%,1);
return ch%;
end;

func StageMkrOffline%(vch%[],epdur)
var i%,t,mn[4];
var code%[4], code0%[4],lbl$,thr2:=0.2;
code0%[0]:=9;                                           ' code for end of epoch markers (ie distinct from doubt and ambiguity)

View(tvh%);
t:=0;
repeat
    MemSetItem(sstatech%[anr%-1],0,Min(MaxTime(),t+epdur),code0%[]); ' add terminator to stop flickering colour between last processed epoch and end of file 
    for i%:=0 to 3 do
        if ChanKind(vch%[i%])=9 then
            mn[i%]:=ChanMeasure(vch%[i%],2,t,Min(t+epdur,MaxTime())); ' mean of W, N, R is value between 0 and 1
        endif;
    next;
    docase
    case ArrSum(mn[:3])>thr and mn[3] < thr2 then       ' assign code if time in recognised sleep states>thr and amount of conflict < thr2
        i%:=Max(mn[]);                                  ' majority state for current epoch
        code%[0]:=i%+1;
        lbl$:=ss$[code%[0]];
    case mn[3]>=thr2 then                               ' ambiguous state, ie significant overlap of  states
        lbl$:=ss$[4];                                   ' label for ambiguous epochs set in dialog
        code%[0]:=4;                                    ' WM colour 0   = White +AMbiguous
    else            
        code%[0]:=5;
        lbl$:= ss$[0];                           ' DOUBT  % time assigned to sleep states is less than chosen threshold   code%[0]
    endcase;
    MemSetItem(sstatech%[anr%-1],0,t,code%[],lbl$);   
    t+=epdur+BinSize();
    if t mod 400.0 <1 then   
        ToolbarText(Print$("Plotting Stage Marker: %.0f%%",t*100.0/MaxTime()));
        Yield();
    endif;  
until t>=MaxTime();

'delete temporary terminators
MarkMask(sstatech%[anr%-1], 0);                         ' set mode 0
MarkMask(sstatech%[anr%-1],-1, 1,-1);                   ' include everything (reset)
MarkMask(sstatech%[anr%-1], 0, 0, -1);                  ' exclude everything in layer 0
MarkMask(sstatech%[anr%-1], 0, 1, 9);                   ' include terminators only
MemDeleteTime(sstatech%[anr%-1],3,0,MaxTime());         ' delete all
MarkMask(sstatech%[anr%-1],-1, 1,-1);                   ' include everything
MarkMask(sstatech%[anr%-1],0,0,255);                    ' code 255 hidden
ToolbarText("");
return 1;
end;

func StageMkrOnline%(vch%[][],epdur,t)
'vch%[]    virtual sleep stage markers
'a%        index of the experimental animal
'epdur     duration of epochs
't         current time
var i%,code%[4],code0%[4],mn[4],lbl$,a%,sz%;

code0%[0]:=9;                                           ' end of epoch code
View(tvh%);
sz%:=Len(vch%[0][]);
if t>lasttm+epdur then   
'if t>lasttm then       'AV edited so doesn't have to be plus one epdur
    for a%:=0 to sz%-1 do                               ' process all sleep stage channels
        MemSetItem(sstatech%[a%],0,lasttm+epdur,code0%[],""); ' end of last stage (code =9 means end of epoch)
        MemSetItem(sstatech%[a%],0,lasttm+epdur+BinSize(),code%[],""); ' beginning of next stage
    next;
    for a%:=0 to sz%-1 do                               ' for each animal...
        for i%:=0 to 3 do                               ' assign state to the the epoch that just ended
            if ChanKind(vch%[i%][a%])=9 then
                mn[i%]:=ChanMeasure(vch%[i%][a%],2,lasttm,lasttm+epdur); ' mn[i%] is the proportion of time in each state during current epoch
            else
                mn[i%]:=0.0;
            endif;
        next;
        docase
        case ArrSum(mn[:3])>thr and mn[3]<=thr2 then
            i%:=Max(mn[]);                              ' assign to state with highest % time
            code%[0]:=i%+1;
            lbl$:=ss$[code%[0]];
        case mn[3]>=thr2 then
            code%[0]:=4;
            lbl$:=ss$[4];                               ' "?";
        else
            code%[0]:=5;
            lbl$:= ss$[code%[0]];
        endcase;                                        ' special label for conflict 
        
        MarkEdit(sstatech%[a%],lasttm,code%[],lbl$);
    next;
    lasttm:=lasttm+epdur+BinSize();                     ' onset time of  stage in progress
endif;
return 1;
end;

func SSDefChnge%(item%)
var ditm%,dchn%,i%,stp;
var thr,ch%,dummy%[4]; 
var cpos:=5;

if item%=0 then
    DlgEnable(not Max(rrchk%,onofflineflg%),-5,-6,-7);  ' Disable <Suggest> for online or Rerun
    if ttableflg% then                                  ' show scheduled time of pulse onset if online +scheduled set.
        DlgVisible(1,di%[:3]);
    else
        DlgVisible(0,di%[:3]);
    endif;                                              ' time window item
endif;

if item%=0 and anr%>1 then                              ' only allow symbols for doubt and ambiguous stages to be set for animal 1
    DlgEnable(0,27,28);
else
    DlgEnable(1,27,28);
endif;

if item%<=3 then
    DlgEnable(DlgValue(1),7,10,13,16,19);               ' en/dis-able Wake items according to check box state
    DlgEnable(DlgValue(2),8,11,14,17,20);               ' ditto fro NREM
    DlgEnable(DlgValue(3),9,12,15,18,21);               ' and REM   
endif;
if item%>0 and item%<4 then ii%:=item%; endif;          ' use global <ii%> to pass change of checkbox state to dlg idle

for i%:=0 to 3 do
    if DlgValue(i%+1)=1 or i%=3 then                    ' box checked (or time to do the ambig chan)
        if ChanKind(ssch%[i%][anr%-1])<>9 then
            if i%=3 then
                ssch%[i%][anr%-1]:=VirtualChan(0,"",0,stepsz,0); ' ambig channel
            else                
                ssch%[i%][anr%-1]:=VirtualChan(0,"",DlgValue(19+i%)); ' new virtual stage channels
            endif;            
            ChanTitle$(ssch%[i%][anr%-1],Print$("%s[%d]",sslbl$[i%],eegch%[anr%-1]));
            ChanColourSet(ssch%[i%][anr%-1],1,r[i%],g[i%],b[i%]);         
            ChanWeight(ssch%[i%][anr%-1],0.33);
            YRange(ssch%[i%][anr%-1],0,1.1);
        endif;
        ChanShow(ssch%[i%][anr%-1]);
        ChanSelect(ssch%[i%][anr%-1],1);
    else                                                ' box unchecked
        if i%<> 3 and ChanKind(ssch%[i%][anr%-1])=9 then ' if W,N or R channel exists then
            ChanDelete(ssch%[i%][anr%-1]);              ' delete it
            ssch%[i%][anr%-1]:=0;
            ssexpr$[i%][anr%-1]:="";                    ' remove previous expression from the list
        endif;      
    endif;
next;
if DlgValue(1)=0 and DlgValue(2)=0 and DlgValue(3)=0 and ChanKind(ssch%[3][anr%-1])=9 then
    ChanDelete(ssch%[3][anr%-1]);                       ' delete ambig channel if W,N and R do not exist
    ssch%[3][anr%-1]:=0;                                ' trap possibility of trying to group a deleted channel
    ssexpr$[3][anr%-1]:="";                             ' and remove stored expression
endif;

if ChanKind(deltach%[anr%-1])=9 and ArrSum(ssch%[][anr%-1])>0 then ' cope if required channels were deleted
    ArrConst(dummy%[],ssch%[][anr%-1]);
    ArrSort(dummy%[],1);                                ' sort descending
    if ArrSum(dummy%[])>0 then
        ChanOrder(deltach%[anr%-1],-1,Print$("%d",dummy%[])); ' trap crash if first chan nr in group to order is zero.
    endif;
endif;

if item%=0 or item%=1 then                              ' W checkbox
    if DlgValue(1) then
        ditm%:=10; dchn%:=4; cpos:=2;
        for i%:=1 to 2 do
            thr:= DlgValue(ditm%);
            if i%=1 then ch%:=DlgValue(dchn%) else ch%:=pwrlst%[DlgValue(dchn%)+1]; endif;
            
            '            if thr>=YHigh(ch%) then
            '                YRange(ch%,0,2*thr);                    ' make sure that hcursor default setting is in range
            '            endif;
            stp:=(YHigh(ch%)-YLow(ch%))/250.0;
            stp:=Trunc(stp*10000.0)/10000.0;            ' 4 decimal places
            if stp=0 then stp:=0.0001; endif;
            DlgValue(ditm%+2000,stp);                   ' set initial threshold spinner step
            hc%[i%]:=HCursorNew(ch%,thr);
            HCursorLabel(4,hc%[i%],"W: %.3p");
            HCursorLabelPos(hc%[i%],cpos);
            lasthcch%[i%-1]:=ch%;                       ' remember the channel
            cpos+=5;
            ditm%+=9; dchn%+=9;
        next;
    else
        HCursorDelete(hc%[1]); hc%[1]:=9;
        HCursorDelete(hc%[2]); hc%[2]:=9;
    endif;    
endif;

if item%=0 or item%=2 then                              ' N checkbox
    if DlgValue(2) then
        ditm%:=11; dchn%:=5; cpos:=8;
        for i%:=3 to 4 do
            thr:= DlgValue(ditm%);
            if i%=3 then ch%:=DlgValue(dchn%) else ch%:=pwrlst%[DlgValue(dchn%)+1]; endif;
            '            if thr>=YHigh(ch%) then
            '                YRange(ch%,0,2*thr);                    ' make sure that hcursor default setting is in range
            '            endif;
            stp:=(YHigh(ch%)-YLow(ch%))/250.0;
            stp:=Trunc(stp*10000.0)/10000.0;            ' 3 decimal places
            DlgValue(ditm%+2000,stp);                   ' set a suitable threshold spinner step
            hc%[i%]:=HCursorNew(ch%,thr);
            HCursorLabel(4,hc%[i%],"NR: %.3p");
            HCursorLabelPos(hc%[i%],cpos);            
            lasthcch%[i%-1]:=ch%;                       ' remember the channel
            cpos+=5;
            ditm%+=9; dchn%+=9;
        next;
    else
        HCursorDelete(hc%[3]);  hc%[3]:=9;
        HCursorDelete(hc%[4]);  hc%[4]:=9;
    endif;    
endif;

if item%=0 or item%=3 then                              ' R checkbox
    if DlgValue(3) then
        ditm%:=12; dchn%:=6; cpos:=14;
        for i%:=5 to 6 do
            thr:= DlgValue(ditm%);
            if i%=5 then ch%:=DlgValue(dchn%) else ch%:=pwrlst%[DlgValue(dchn%)+1]; endif;
            ' OPTIMISE TRACE INSTEAD.This should bring the desired threshold into the visble Y-range in most cases.
            '            if thr>=YHigh(ch%) then
            '                YRange(ch%,0,2*thr);                    ' make sure that hcursor default setting is in range
            '            endif;            
            stp:=(YHigh(ch%)-Ylow(ch%))/250.0;
            stp:=Trunc(stp*10000.0)/10000.0;            ' 3 decimal places
            DlgValue(ditm%+2000,stp);                   ' set a suitable threshold spinner step 
            hc%[i%]:=HCursorNew(ch%,thr);
            HCursorLabel(4,hc%[i%],"REM: %.3p");
            HCursorLabelPos(hc%[i%],cpos);
            
            lasthcch%[i%-1]:=ch%;                       ' remember the channel
            cpos+=5;
            ditm%+=9; dchn%+=9;
        next;
    else
        HCursorDelete(hc%[5]);   hc%[5]:=9;
        HCursorDelete(hc%[6]);   hc%[6]:=9;
    endif;    
endif;

if onofflineflg%=0 or rrchk%=1 then                     ' set sensible spinner step for emg thresholds based on signal if possible
    if item%>=4 and item%<=6 or item%=0 then                         
        for i%:=4 to 6 do
            stp:=(YHigh(DlgValue(i%))-YLow(DlgValue(i%)))/250.0; ' set step to 0.2% of visible Y-range.
            stp:=Trunc(stp*1000.0)/1000.0;              ' 3 decimal places
            DlgValue(i%+2000+6,stp);
        next;
    endif;
    ' '===
    var rnge,hcn%;
    if item%>=13 and item%<=15 then                     ' reset spinner step and move hcursor if use selects a different spectral channel
        ch%:=pwrlst%[DlgValue(item%)+1];                ' new channel
        rnge:=YHigh(ch%)-YLow(ch%);
        stp:=rnge/250.0;                                ' set spinner to 250 steps in visible range
        stp:=Trunc(stp*10000)/10000;
        if stp<0.0002 then stp:= 0.0002; endif;         ' step limited to 4 decimal places
        DlgValue(item%+6+2000,stp);                     ' not allowed to truncate to zero
        docase
        case item%=13 then hcn%:=hc%[2];
        case item%=14 then hcn%:=hc%[4];            
        case item%=15 then hcn%:=hc%[6];
        endcase;        
        HCursor(hcn%,YLow(ch%)+0.5*rnge);               ' move the cursor
    endif;
endif;

if item%=7 or item%=16 then                             ' disable state if no expressions were set
    if DlgValue(7)=2 and DlgValue(16)=2 then
        DlgValue(7,0);
        DlgValue(1,0);
        DlgEnable(DlgValue(1),4,7,10,13,16,19);         ' en/dis-able Wake items according to check box state
    endif;
endif;

if item%=8 or item%=17 then                             ' disable state if no expressions were set
    if DlgValue(8)=2 and DlgValue(17)=2 then      
        DlgValue(8,0); 
        DlgValue(2,0);
        DlgEnable(DlgValue(2),5,8,11,14,17,20);         ' NREM
    endif;
endif;

if item%=9 or item%=18 then                             ' disable state if no expressions were set
    if DlgValue(9)=2 and DlgValue(18)=2 then
        
        DlgValue(9,0);
        DlgValue(3,0);
        DlgEnable(DlgValue(3),6,9,12,15,18,21);         ' REM  
    endif;
endif;

if item%>0 then
    stagedefineflg%:=1;                                 ' flag option to save changes inside <Quit>
endif;

var ach%;
ditm%:=10; dchn%:=4; ach%:=DlgValue(dchn%);
'fix for dlgvalubug
for i%:=1 to 6 do
    if HCursorExists(hc%[i%]) then
        LinkDlgToHcsr(item%,ditm%,hc%[i%],ach%,tvh%);   ' DlgValue(dchn%)
    endif;
    if i% mod 2=1 then                                  ' if i% <odd>  then jump to 2nd item of a pair
        ditm%+=9; dchn%+=9;  ach%:=pwrlst%[DlgValue(dchn%)+1]; ' offset to next level and channel  items
    else                                                ' else jump to start of next pair
        ditm%-=8; dchn%-=8;    ach%:=DlgValue(dchn%);      
    endif;   
next;
return 1;
end;

func SSDefidl%()                                        ' link h cursors to Define stages dialog
var lastexpr$;
var ditm%,dchn%,c%,i%;

View(tvh%);
ditm%:=10; dchn%:=4;

for i%:=1 to 5 step 2 do                                ' emg cursors
    if HCursorExists(hc%[i%]) then        
        xLinkHCsrToDlg(ditm%+c%,hc%[i%],DlgValue(dchn%+c%),tvh%); ' update emg thr in dialog when hcursor dragged
    endif;
    c%+=1;                                              ' offset to next channel/threshold item
next;
c%:=0;
ditm%:=19; dchn%:=13;                                   ' pwr band cursors
for i%:=2 to 6 step 2 do
    if HCursorExists(hc%[i%]) then       
        xLinkHCsrToDlg(ditm%+c%,hc%[i%],pwrlst%[DlgValue(dchn%+c%)+1],tvh%); ' update pwr thr in dialog when hcursor dragged
    endif;
    c%+=1;                                              ' offset to next channel/threshold item
next;

var pch%,aflg%;
for i%:=0 to 2 do
    if DlgValue(i%+1) then                              ' if checkbox state changed then update
        pch%:=pwrlst%[DlgValue(13+i%)+1];
        docase                                          ' update virtual channel expressions based on dialog settings
        case DlgValue(7+i%)=2 then                      ' ignore emg level
            ssexpr$[i%][anr%-1]:=Print$("ch(%d)%s%.3f",pch%,op$[DlgValue(16+i%)],DlgValue(19+i%)); ' ***
        case DlgValue(16+i%)=2 then                     ' ignore pwr band
            ssexpr$[i%][anr%-1]:=Print$("ch(%d)%s%.3f",DlgValue(4+i%),op$[DlgValue(7+i%)],DlgValue(10+i%));      
        else
            ssexpr$[i%][anr%-1]:=Print$("(ch(%d)%s%.3f)*(ch(%d)%s%.3f)",DlgValue(4+i%),op$[DlgValue(7+i%)],
            DlgValue(10+i%),pch%,op$[DlgValue(16+i%)],DlgValue(19+i%)); ' emg and power in band
        endcase;
        VirtualChan(ssch%[i%][anr%-1],0,lastexpr$);
        if ssexpr$[i%][anr%-1]<>lastexpr$ then
            VirtualChan(ssch%[i%][anr%-1],ssexpr$[i%][anr%-1],pch%); ' update expression of existing channel  
            aflg%:=1;                                   ' flag to update ambig marker channel if any stage channel expression was changed
        endif;
    endif;
next;
if aflg% or (ii% >0 and ii%<4) then                     ' an expression changed or stage channel en/dis-abled
    var vexpr$,xpr$;                                    ' update ambiguity marker channel
    for i%:=0 to 2 do
        if DlgValue(i%+1) then                          ' sschk%[i%][anr%-1]
            VirtualChan(ssch%[i%][anr%-1],0,vexpr$);    ' get expressions of all enabled virtual stage channels
            xpr$+=vexpr$+"+";
        endif;
    next;
    xpr$:=DelStr$(xpr$,Len(xpr$),1);                    ' delete final <+>
    xpr$:=Print$("hwr(%s-1)",xpr$);                     ' show only ambiguous time ranges, ie >1
    VirtualChan(ssch%[3][anr%-1],xpr$,0,0.1);
    ii%:=0;
endif;
if SampleStatus()=2 or rrchk% then
    Idle%();                                            ' if online or rerunning then continue main idle while Stage Define dialog is open
endif;
return 1;
end;

proc EditStates(editch%,c%,lbl$,opt%)                   ' change single epoch or all in time range to selected sleep state
'editch%	channel number of state channel to edit
'c%	new state code (1: WAKE; 2: NREM etc.)
'lbl$	label for the new sleep state (W, N, R etc.)
'opt%	0: single epoch mode; 1: multi-epoch mode
var t,codes%[4];

codes%[0]:=c%;
t:=LastTime(editch%,Cursor(1));
if opt%=0 then
	MarkEdit(editch%,t,codes%[],lbl$);
else
	CursorRenumber();
	repeat
		MarkEdit(editch%,t,codes%[],lbl$);
		t:=NextTime(editch%,t);
	until t>=Cursor(2) or t<0;
endif;
if vmflag% then
    VMarkShow%();                                       ' update  vertical markers at transitions between states
endif;
Draw();
return;
end;

func Edit%()
var chlst%[3];

View(tvh%);
ChanList(chlst%[],"=[Ss][Tt][Aa][Gg][Ee]",32+2048);
if chlst%[0]=0 then
    Newsflash("No visible <Stage> channel",30,75,5,0);
else
    editch%:=chlst%[1];
    EditButtons();
endif;
return 1;
end;

proc EditButtons();
ToolbarClear();
ToolbarSet(1, "&Back||Hotkey: B;  Back to main toolbar.", Back%);
ToolbarSet(2, "AMBIG. (&5)", Ambig%);
ToolbarSet(3, "DOUBT (&4)", Doubt%);
ToolbarSet(4, "REM (&3)", Rem%);
ToolbarSet(5, "NREM (&2)", Nrem%);
ToolbarSet(6, "WAKE (&1)", Wake%);
stagesel%:=3;
StageSelect%();                                         ' set <DOUBT> as initial stage to seek with <Next/Previous>
ToolbarSet(8, "Next >>|0x27|Hotkey: right cursor arrow", NextEpoch%);
ToolbarSet(10, "<< Previous|0x25|Hotkey: Left cursor arrow", PreviousEpoch%);
ToolbarSet(swone%,"&Single Epoch Mode||Hotkey: S",OneEpoch%);
ToolbarSet(swmulti%,"&Multi Epoch Mode||Hotkey: M",MultiEpoch%);
ToolbarSet(rbtn%,"  forward one screen|0xBE|Shift 1 screen right;  Hotkey: .(Period)",RJmp%);  'Hotkeys use Virtual key codes (not ascii)
ToolbarSet(lbtn%," back one screen|0xBC|Shift 1 screen left:  Hotkey: ,(comma)",LJmp%);
OneEpoch%();                                            ' default mode is one epoch at a time
return;
end;

func StageSelect%()                                     ' select which sleep stage to find with <Next/Previous>
var lst%[10];

stagesel%+=1;
if stagesel%>7 then stagesel%:=1; endif;
docase
case stagesel%=1 then mc%:=1; lbl$:=ss$[1];
case stagesel%=2 then mc%:=2; lbl$:=ss$[2];
case stagesel%=3 then mc%:=3; lbl$:=ss$[3];
case stagesel%=4 then mc%:=0; lbl$:=ss$[4];
case stagesel%=5 then mc%:=5; lbl$:=ss$[5];
case stagesel%=6 then mc%:=6; lbl$:="Any";
case stagesel%=7 then                                   ' Next stimulation on <op> channel
    mc%:=7; lbl$:="Stimulus";
    ChanList(lst%[],"=op",4+2048);                      ' find visible outputs channel
    if lst%[0]=0 then                                   ' if not found then
        ChanList(lst%[],"=[Pp]red",4+2048);             ' find <predicted outputs> channel
    endif;
    if lst%[0]>0 then find_opch%:=lst%[1];              ' save this channel number
    else
        stagesel%:=1; mc%:=1; lbl$:=ss$[1]              ' if no outputs channel then omit this option, jump to next.
    endif;
endcase;   
ToolbarClear(9);                                        ' redo button with new label
ToolbarSet(9,Print$("  <%s>  |0x26|Click repeatedly until the desired sleep stage displays. HOTKEY: ^",lbl$),StageSelect%);
return 1;
end;

func NextEpoch%()                                       ' move to next epoch of selected type
Move%(1);
return 1;
end;

func Move%(dir%);                                       ' move cursor to Next (1) or Previous (-1) epoch of selected type
var hwidth,tw,t1,t2,codes%[4],tick;

View(tvh%);
hwidth:=(XHigh()-XLow())/2.0;
if mc%=7 then                                           ' next/previous stimulus
    t1:=NextTime(find_opch%,Cursor(1)+trdur);           ' Find next stimulation time (trdur is length of train set in Preferences)
    t2:=LastTime(find_opch%,Cursor(1)-trdur);
    docase   
    case (dir%>0 and t1<0) or (dir%<0 and t2<0) then
        Newsflash(Print$("No more <%s> stimuli found.",lbl$),2,75,5,0);
        return 1;
    case dir%>0 then
        Cursor(1,t1);                                   ' middle of next epoch of selected type
    case dir%<0 then
        Cursor(1,t2);                                   ' middle of previous epoch of selected type
    endcase;
    XRange(Cursor(1)-hwidth,Cursor(1)+hwidth);    
else                                                    ' next/previous sleep stage
    tick:=2.0*BinSize(editch%);
    MarkMask(editch%, 0);                               ' set mode 0
    t1:=LastTime(editch%,Cursor(1)+tick);               ' ,codes%[]);
    t2:= NextTime(editch%,Cursor(1)+tick);
    tw:=(t2-t1)/2.0;
    MarkMask(editch%,-1, 1,-1);                         ' include everything (reset)
    if mc%=6 then
        MarkMask(editch%, 0, 0, 9,255);                 ' exclude marker 0 (terminators only)
    else
        MarkMask(editch%, 0, 0, -1);                    ' exclude everything in layer 0
        MarkMask(editch%, 0, 1,mc%);                    ' include the code for  selected sleep state (ie jump to next epoch regardless of type)
    endif;
    t1:=NextTime(editch%,Cursor(1));                    ' next epoch of type
    t2:=LastTime(editch%,Cursor(1)-tw,codes%[]);        ' -tick
    MarkMask(editch%,-1, 1,-1);                         ' reset
    MarkMask(editch%,0,0,255);                          ' hide code 255
    docase   
    case (dir%>0 and t1<0) or (dir%<0 and t2<0) then
        Newsflash(Print$("No more <%s> episodes found.",lbl$),2,75,5,0);
        return 1;
    case dir%>0 then
        Cursor(1,LastTime(editch%,t1+tw));              ' middle of next epoch of selected type
    case dir%<0 then
        Cursor(1,LastTime(editch%,t2+tw));              ' middle of previous epoch of selected type
    endcase;
    XRange(Cursor(1)-hwidth,Cursor(1)+hwidth);    
endif;
return 1;
end;

func PreviousEpoch%()                                   ' move to previous epoch of selected type
Move%(-1);
return 1;
end;

func OneEpoch%()                                        ' single sleep stage editing mode
CursorSet(1);
ToolbarEnable(swone%,off%);
ToolbarEnable(swmulti%,on%);
ToolbarEnable(8,on%);                                   ' enable Next/Previous buttons
ToolbarEnable(9,on%);
ToolbarEnable(10,on%);
ToolbarText("DRAG CURSOR TO MARK EPOCH TO EDIT AND PRESS A BUTTON:    <SINGLE EPOCH MODE>");
multiflg%:=0;
return 1;
end;

func MultiEpoch%()                                      ' multi stage editing mode (Time range)
CursorSet(2);
ToolbarEnable(swmulti%,off%);
ToolbarEnable(swone%,on%);
ToolbarEnable(8,off%);                                  ' disable Next/Previous buttons
ToolbarEnable(9,off%);
ToolbarEnable(10,off%);
ToolbarText("DRAG CURSORS TO BRACKET EPOCHS TO EDIT AND PRESS A BUTTON:    <MULTI EPOCH MODE>");
multiflg%:=1;
return 1;
end;

func Nrem%()                                            ' change state(s) to NREM
EditStates(editch%,2,"N",multiflg%);
return 1;
end;

func Rem%()                                             ' change state(s) to REM
EditStates(editch%,3,"R",multiflg%);
return 1;
end;

func Wake%()                                            ' change state(s) to WAKE
EditStates(editch%,1,"W",multiflg%);
return 1;
end;

func Doubt%()                                           ' change state(s) to <DOUBT>
EditStates(editch%,5,"D",multiflg%);
return 1;
end;

func Ambig%()                                           ' change state(s) to <Ambiguous>
EditStates(editch%,4,"?",multiflg%);
return 1;
end;

func Back%()
var btn%[9]:={4,5,6,8,9,10,11,14,15};

ToolbarText("");
MainToolBtns();
if vmflag%=1 then
    ToolbarClear(vmbtn%);
    ToolbarSet(vmbtn%,"Hide &Transitions||Hotkey: T",VMarkHide%);
endif;
ToolbarEnable(all%,on%);
ToolbarEnable(btn%[],off%);
return 1;
end;

func ReptDlgChnge%(item%)
var stepsz,nep%;

stepsz:=Val(ChanComment$(DlgValue(1)));                 ' get epoch duration
if item%<=1 then
    if stepsz=0 then stepsz:=20.0; endif;
    DlgValue(4+2000,stepsz);                            ' set spinner increment to epoch duration
endif;
if item%=0 or item%=4 then                              ' show number of epochs in selected time range
    nep%:=DlgValue(4)/stepsz;
    DlgValue$(di%[0],Print$("%d",nep%));
endif;
return 1;
end;

func Report%()
var ok%;
var t1,t2,clearchk%;                                    ' used to recalculate epoch duration
var chlst%[2],ssch%,stime,etime,epdur;

View(tvh%);
etime:=MaxTime();
ChanList(chlst%[],"=[Ss][Tt][Aa][Gg][Ee]",32+2048);
if chlst%[0]=0 then
    Newsflash("No visible stage channel",10,75,5,0);
    return 1;
endif;
ssch%:=chlst%[1];
drandx%:=15;
DlgCreate("Table Set-up",dxra[drandx%],dyra[drandx%]);
DlgAllow(511,0,ReptDlgChnge%);
DlgChan(1,"Stage channel",32+2048);
DlgXValue(2,"Start time (s)");
DlgXValue(3,"End time (s)");
DlgReal(4,"Block duration (s)",30.0,etime,0,0,1);
DlgText("Number of epochs",2,5);
DlgGroup("",24,4.7,15,1.1);
di%[0]:=DlgText("",24.5,5.1,8);
DlgCheck(5,"Clear the log before printing.",0,6);
DlgButton(0,"Cancel",Cancelx%);
DlgButton(1,"OK",OKx%);
ok%:=DlgShow(ssch%,stime,etime,blockdur,clearchk%);
if not ok% then return 1; endif;
if stime > etime or Abs(etime - stime) < blockdur then 
    Message("Error|Invalid time range. Please try again.");
    return 1;
endif;

if clearchk% then                                       ' clear the log
	View(LogHandle());
	EditSelectAll();
	EditClear();
endif;
View(LogHandle()).TabSettings(10,1);
View(tvh%);

var style%,style$[3];
style$[0]:="s"; style$[1]:="h:m:s"; style$[2]:="ToD"; 
style%:=XAxisStyle();                                   ' show times in same format as X-axis (not ms!)
style%-=1;                                              ' style 1: h:m:s; 2: time of day
if style%<0 or style%>2 then style%:=0; endif;          ' default to seconds

MarkMask(ssch%,0);                                      ' set mode 0
MarkMask(ssch%,-1,1,-1);                                ' include everything (reset)
MarkMask(ssch%,0,0,9,255);                              ' hide terminators (code 0 level 0) and intentionally hidden (code 255)
t1:=NextTime(ssch%,stime);
t2:=NextTime(ssch%,t1);
epdur:=t2-t1;                                           ' get epoch duration
if (etime-stime) <epdur then
    Message("Error|Invalid time range (-less than 1 epoch!). Please try again.");
    return 1;
endif;
PrintLog("Filename:\t%s%s%s\n",FileName$(3),FileName$(4),FileName$(5));
PrintLog("File date:\t%s\n",FileDate$(2,3,3,2," "));
PrintLog("Stage chan:\t% d\n",ssch%);
PrintLog("Epoch (s)\t% 4.1f\n",epdur);
Printlog("Block (s)\t%4.1f\n\n",blockdur);
PrintLog("\nSection\t Start\t \tEpoch counts... \t\t\t\t\t percent time in state...\n\t (%s) \t  \t WAKE \t NREM \t REM \t ???\t DOUBT \t\t WAKE \t NREM \t REM \t ??? \t DOUBT\n",style$[style%]);

var i%,j%,k%,st,et,done%;
var nb%; nb%:=1+(etime-stime)/blockdur;                 ' divide time range into nb% blocks
var noftype%[5][nb%];                                   ' [stage][blocknr] count of epochs of each stage per block
var nexpected%; nexpected%:=Ceil(blockdur/epdur);
var mcodes%[5];
mcodes%[0]:=1; mcodes%[1]:=2; mcodes%[2]:=3; mcodes%[3]:=4;  mcodes%[4]:=5; ' W, N, R, ? D.
View(tvh%);
for i%:= 0 to 4 do                                      ' for each state...
	MarkMask(ssch%,0);                                  ' set mode 0
	MarkMask(ssch%,-1,1,-1);                            ' include everything (reset)
	st:=Max(0.0,LastTime(ssch%,stime));                 ' start at first stage onset after stime ***
	MarkMask(ssch%,0,0,-1);                             ' exclude everything in layer 0
	MarkMask(ssch%,0,1,mcodes%[i%]);                    ' include selected stage
	done%:=0;
	j%:=0;	
	repeat
		et:=st+blockdur;                                ' and each block...
        if et>etime then et:=etime; endif;
		noftype%[i%][j%]:=Count(ssch%,st,et);           ' count epochs of each type
		st+=blockdur;
        if st>=etime then break; endif;
		j%+=1;
	until et>=etime;
next;
MarkMask(ssch%,-1, 1,-1);                               ' include everything (reset)
MarkMask(ssch%,0,0,255);                                ' except code 255
st:=stime;
var pc[5][nb%],pccvt,ff$;

pccvt:=100.0*epdur/blockdur;
ArrConst(pc[][],noftype%[][]);
ArrMul(pc[][],pccvt);
st:=stime;
if style%=0 then
    for k%:=0 to j%-1 do                                ' for each time slice ...
        PrintLog("%4d\t%6.1f\t\t%4d\t%4d\t%4d\t%4d\t%4d\t\t%4.1f\t%4.1f\t%4.1f\t%4.1f\t%4.1f\t",
        k%+1,st,noftype%[0][k%],noftype%[1][k%],noftype%[2][k%],noftype%[3][k%],noftype%[4][k%],
        pc[0][k%],pc[1][k%],pc[2][k%],pc[3][k%],pc[4][k%]);
        st+=blockdur;
        if ArrSum(noftype%[][k%])<>nexpected% then ff$:="?\n"; else ff$:="\n"; endif;
        PrintLog(ff$);
    next;
else
    var st$,hr%,min%,sec%;
    for k%:=0 to j%-1 do                                ' for each time slice ...
        'PrintLog(style%);
        TimeCvt%(st,style%,hr%,min%,sec%,st$);
        PrintLog("%4d\t%s\t\t%4d\t%4d\t%4d\t%4d\t%4d\t\t%4.1f\t%4.1f\t%4.1f\t%4.1f\t%4.1f\n",
        k%+1,st$,noftype%[0][k%],noftype%[1][k%],noftype%[2][k%],noftype%[3][k%],noftype%[4][k%],
        pc[0][k%],pc[1][k%],pc[2][k%],pc[3][k%],pc[4][k%]);
        st+=blockdur;	
    next;
endif;
View(LogHandle());
Window(0,0,100,97,1);
FrontView(LogHandle());
View(tvh%);
return 1;
end;

func TimeCvt%(s,mode%,&hr%,&min%,&sec%,&st$)            ' Convert input time in seconds to hr:min:sec or time of day format
'Retuns the time in the altenative formats that can be shown on the x-axis of a time view
'sxx                                          input time in seconds
'modexx%:                             0: sets h :m :s format;
'                                         1:   sets time of day format. In this mode, the current view must be a time view:
'hrxx%,minxx%,secxx%         time in hours minutes and seconds (rounded to nearest second) is passed in these arguments
'returns                                -1 if mode 1 selected by the current view is not a time view.
'                                     1 if all is well.

var vh%,td%[3];
var tsec%,amin%;

docase
case mode%=1 then                                       ' convert to hh:mm:ss elapsed
    tsec%:=Round(s);                                    ' current time in seconds    
case mode%=2 then                                       ' convert to time of day
    vh%:=View();
    if ViewKind(vh%)<>0 then return -1; endif;          ' not a time view
    FileTimeDate(td%[]);                                ' creation time ss:ms:hh format
    tsec%:=Round(s)+td%[0]+td%[1]*60 +td%[2]*3600;      ' current time is seconds since midnight 
endcase;
sec%:=tsec% mod 60;
amin%:=tsec%/60;
min%:=amin% mod 60;
hr%:=amin%/60;
st$:=Print$("%02d:%02d:%02d",hr%,min%,sec%);
return 1;
end;

proc xLinkHCsrToDlg(ditm%,hcsr%,chan%,timevh%)          ' update dialog item when user drags Hcursor
'This procedure links a Hcursor position to a DlgReal() item so that the dialog item updates when the Hcursor is dragged.
'It must be called in the Idle function of the dialog.

'Arguements:
'ditm%:	the dialog item to link to a Hcursor position
'hcsr%:	the number of the Hcursor to link to the dialog item.
'chan%:	the channel number that the cursor is attached to.
'timevh%:	the handle of the view containing the Hcursor
var vh%;
vh%:=View();                                            ' remember current view
if ViewKind(timevh%)= 0 and HCursorExists(hcsr%) then
    if HCursorChan(hcsr%)<> chan% then                  ' user selected new channel in dialog (or dragged cursor to new channel)
		HCursor(hcsr%,lasthc[hcsr%],chan%);
	endif;	
	if HCursor(hcsr%)<> lasthc[hcsr%] then              ' user moved horizontal cursor
		DlgValue(ditm%,HCursor(hcsr%));                 ' adjust dialog item to match
		lasthc[hcsr%]:=HCursor(hcsr%);
	endif;
endif;
View(vh%);                                              ' restore previous view
return;
end;

func samp_end(tdate[])

'Declare variables:
var ok%,dummy0%,int1%,int2%,int3%,int4%,int5%,int6%;

'Set the variables above for initial values
drandx%:=16;
DlgCreate("Choose sampling time end",dxra[drandx%],dyra[drandx%]);                  ' Start new dialog
DlgLabel(1,"When would you like to end sampling time?");
DlgInteger(2,"Time (seconds)",0,60,0,0,1);
DlgInteger(3,"Time (minutes)",0,60,0,0,1);
DlgInteger(4,"Time (24 hour clock)",0,23,0,0,1);
DlgInteger(5,"Date(day of month)",1,31,0,0,1);
DlgInteger(6,"Month",1,12,0,0,1);
DlgInteger(7,"Year",2016,2099,0,0,1);
DlgButton(0,"Cancel",Cancelx%);
DlgButton(1,"OK",OKx%);
ok% := DlgShow(dummy0%,int1%,int2%,int3%,int4%,int5%,int6%); ' ok% is 0 if user cancels,  variables updated if not

tdate[0] := int1%;
tdate[1] := int2%;
tdate[2] := int3%;
tdate[3] := int4%;
tdate[4] := int5%;
tdate[5] := int6%;

end;

func SecSinceJan01%(td%[]);                             ' returns that time in seconds since the start of the current year
'td%[]   contains standard time dat info as provided by TimeDate()
var dpm%[12]:={31,28,31,30,31,30,31,31,30,31,30,31};
var copy%[12],now%;
var secperday%:=3600*24;

if (td%[5] mod 4 = 0) then dpm%[1]+=1; endif;           ' 29th Feb
'now in sec since start of year
now%:=td%[0]+td%[1]*60+td%[2]*3600+td%[3]*secperday%;   ' sec since start of current month
if td%[4]>1 then
    ArrConst(copy%[],dpm%[]);
    ArrMul(copy%[],secperday%);                         ' sec per month
    ArrIntgl(copy%[]);                                  ' secs so far in yr
    now%+=copy%[td%[4]-1];                              ' add seconds in previous months this year
endif;
return now%;
end;

func RecSchedule%()                                     ' dialog to set scheduled recording
var ok%;
var dndx%;
var rdur%[3];                                           ' recording duration hr:mm:ss
var sslat%[3];                                          ' latency to scheduled stimulation (hh:mm:ss)
var dlst$[12]:={"Jan","Feb,","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"};
var now%[6],startat%,nowins%;                                    
var done%:=0,days%;

days%:=HmsTod%(rdursec%,0,rdur%[0],rdur%[1],rdur%[2]);  ' convert record duration sec to dy:hh:mm:ss
rdur%[0]+=days%*24;

days%:=HmsTod%(stimonsec%,0,sslat%[0],sslat%[1],sslat%[2]); ' convert stimulus latency to sec to dy:hh:mm:ss
sslat%[0]+=days%*24;

days%:=HmsTod%(stimoffsec%-stimonsec%,0,stdr%[0],stdr%[1],stdr%[2]); ' convert stimulus window duration for dialog
stdr%[0]+=days%*24;

repeat                                                  ' re-open dialog if user settings were invalid <Cancel> to escape
    TimeDate(now%[]);
    nowins%:=SecSinceJan01%(now%[]);
    begin%[3]:= now%[3];                                ' pre-load todays date 
    dndx%:=now%[4]-1;                                   ' convert month to index of month in list
    begin%[5]:=now%[5];    
    drandx%:=17;    
    DlgCreate("Recording schedule",dxra[drandx%],dyra[drandx%]);               ' Start new dialog   
    DlgAllow(511);
    DlgGroup("",13,1,30,2.4);
    DlgText("Day|Day of month",15,1.5);
    DlgText("Month",24,1.5);
    DlgText("Year",35,1.5);
    
    DlgText("Start date",2,2.5);
    DlgInteger(1,6,1,31,15,2.5,1);                      ' day
    DlgList(2,6,dlst$[],12,24.5,2.5);                   ' month
    DlgInteger(3,8,now%[5],2099,34,2.5,1);              ' yr
    DlgGroup("",13,3.5,30,8.6);   
    DlgText(" Hr|24hr clock",15,4);
    DlgText(" Min",24,4);
    DlgText("Sec",35,4);
    DlgText("Start time",2,5);
    DlgInteger(4,8,0,59,34,5,1);                        ' sec
    DlgInteger(5,7,0,59,24,5,1);                        ' min
    DlgInteger(6,6,0,23,15,5,1);                        ' hr
    
    DlgText("Recording\n Duration",2,6.2);
    DlgInteger(7,6,0,240,15,6.5,12);                    ' hr
    DlgInteger(8,7,0,59,24,6.5,1);                      ' min
    DlgInteger(9,8,0,59,34,6.5,1);                      ' sec
    
    DlgText("Time window for stimulation",15.5,8);
    DlgText(" Hr|24hr clock",15,8.6);
    DlgText(" Min",24,8.6);
    DlgText("Sec",35,8.6);
    DlgText("Stimulation\n  on after:",2,9.3);
    DlgInteger(10,6,0,240,15,9.5,12);                     ' hr
    DlgInteger(11,7,0,59,24,9.5,1);                       ' min
    DlgInteger(12,8,0,59,34,9.5,1);                       ' sec
    
    DlgText("Stimulus\nDuration|Set to 0:00:00 for no time limit.",2,10.8);
    DlgInteger(13,6,0,240,15,11,12);                   ' hr
    DlgInteger(14,7,0,59,24,11,1);                     ' min
    DlgInteger(15,8,0,59,34,11,1);                     ' sec
    DlgButton(0,"Cancel",Cancelx%);
    DlgButton(1,"OK",OKx%);
    ok% := DlgShow(begin%[3],dndx%,begin%[5],begin%[:3],rdur%[],sslat%[],stdr%[]);    
    if ok%=0 then rdursec%:=0; break; endif;            ' user cancelled
    
    begin%[4]:=dndx%+1;                                 ' convert from index-of-month to month
    startat%:=SecSinceJan01%(begin%[]);                 ' get requested start time
    if startat%-nowins%<60 then                         ' Check that selected start time is future not past.
        Message("Invalid start time|The start time must be in the future -at least 5 minutes from now.");
        continue;
    else
        ' valid start time
    endif;
    
    rdursec%:=rdur%[0]*3600+rdur%[1]*60+rdur%[2];       ' recording duration in seconds
    if rdursec%<60.0 then
        Message("Invalid record duration|Duration must be at least 5 minutes.");
        continue;
    else
        ' valid recording duration
    endif;
    stimonsec%:=sslat%[0]*3600+sslat%[1]*60+sslat%[2];
    if stimonsec%>rdursec% then
        Message("Invalid stimulus delay|Delay must be shorter than duration of recording!");
    else
        done%:=1;                                       ' valid stimulation latency
    endif;
    stimoffsec%:=stimonsec%+stdr%[0]*3600+stdr%[1]*60+stdr%[2]; ' time to switch off stimulation (sec after sample start)
    if stimoffsec%=stimonsec% then
        Newsflash("Info|No upper time limit for stimulation was selected.",3,75,5,0);
        stimoffsec%:= 3600*24*7;                        ' set to 1 week of stimulation
    endif;    
until done%;
if done%=1 then
    begin$:=Print$("%d,%d,%d,%d,%d,%d",begin%[2],begin%[1],begin%[0],rdursec%,stimonsec%,stimoffsec%); ' save start time, duration and stim time to registry
    Profile(key$,"begin",begin$);
endif;
'get the scheduled start of stimulation as a string
var tstvh%;
tstvh%:=FileNew(0,0);                                   ' new hidden time view
if tstvh%<0 then Message(Error$(tstvh%)); return 1; endif; ' cope with 1401 switched off
FileTimeDateSet(begin%[]);                              ' set requested start time of recording

stdate0$:=FileDate$(2,3,3,2," ");                       ' date and time of start of recording as strings
sttime0$:=FileTime$(1,1+2+4,0,":");

stdate$:=FileDate$(2,3,3,2," ",stimonsec%);             ' date and time of start of stimulation as strings
sttime$:=FileTime$(1,1+2+4,0,":",stimonsec%);

if stimoffsec%>stimonsec% then
    stdate2$:=FileDate$(2,3,3,2," ",stimoffsec%);       ' date and end time of s of stimulation as strings
    sttime2$:=FileTime$(1,1+2+4,0,":",stimoffsec%);
else
    sttime2$:="No time limit";  stdate2$:="";
endif;
stdate1$:=FileDate$(2,3,3,2," ",rdursec%);              ' date and time of end of recording as strings
sttime1$:=FileTime$(1,1+2+4,0,":",rdursec%);
'==
ToolbarText(Print$("  Start / End recording :  %s (%s) / %s (%s);   Start / End stimulation :  %s (%s) / %s  %s",
sttime0$,stdate0$,sttime1$,stdate1$,sttime$,stdate$,sttime2$,stdate2$));

PrintLog("  Start / End recording :  %s (%s) / %s (%s);   Start / End stimulation :  %s (%s) / %s  %s",
sttime0$,stdate0$,sttime1$,stdate1$,sttime$,stdate$,sttime2$,stdate2$);         'ANNE edit Print start and finish time to log

'ToolbarEnable(samplebtn%,off%);       'manual start button OFF
'==
FileClose(0,-1);
return rdursec%;
end;


